 项目初始化与目录结构
bash
# 在现有Next.js项目中创建后台目录结构
mkdir -p app/(admin)
mkdir -p components/features/reits
mkdir -p components/features/auth
mkdir -p components/features/audit
mkdir -p lib/security
mkdir -p lib/auth
mkdir -p lib/monitoring
mkdir -p hooks/admin
mkdir -p types/admin
mkdir -p config/security
2.2 安装依赖
bash
# 核心依赖
pnpm add @tanstack/react-query next-auth @prisma/client bcryptjs
pnpm add crypto-js node-forge jsonwebtoken
pnpm add react-hook-form zod @hookform/resolvers
pnpm add @radix-ui/react-tabs @radix-ui/react-dialog
pnpm add recharts react-table

# 开发依赖
pnpm add -D @types/bcryptjs @types/crypto-js @types/node-forge
pnpm add -D prisma
2.3 权限系统实现
2.3.1 数据库模型（Prisma）
prisma
// prisma/schema.prisma
model User {
  id            String    @id @default(cuid())
  username      String    @unique
  password      String
  email         String    @unique
  role          Role      @relation(fields: [roleId], references: [id])
  roleId        String
  department    String?
  region        String?
  lastLogin     DateTime?
  loginAttempts Int       @default(0)
  lockedUntil   DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

model Role {
  id          String       @id @default(cuid())
  name        String       @unique
  code        String       @unique
  description String?
  permissions Permission[]
  users       User[]
}

model Permission {
  id          String   @id @default(cuid())
  resource    String   // 如 'reit_product_info'
  action      String   // 'create' | 'read' | 'update' | 'delete'
  conditions  String?  // 数据权限条件（JSON）
  role        Role     @relation(fields: [roleId], references: [id])
  roleId      String
}

model LoginAttempt {
  id        String   @id @default(cuid())
  userId    String
  success   Boolean
  ip        String?
  userAgent String?
  timestamp DateTime @default(now())
}

model AuditLog {
  id           String   @id @default(cuid())
  userId       String
  username     String
  action       String
  resourceType String
  resourceId   String?
  oldValue     Json?
  newValue     Json?
  sensitiveData Json?   // 加密存储
  signature    String?   // 环签名
  ipAddress    String?
  userAgent    String?
  result       String   // 'success' | 'failure'
  errorMessage String?
  createdAt    DateTime @default(now())
}
2.3.2 执行Prisma迁移
bash
npx prisma migrate dev --name init_auth
npx prisma generate
2.3.3 认证API（NextAuth.js）
typescript
// app/api/auth/[...nextauth]/route.ts
import NextAuth from 'next-auth';
import CredentialsProvider from 'next-auth/providers/credentials';
import { PrismaAdapter } from '@next-auth/prisma-adapter';
import { prisma } from '@/lib/prisma';
import bcrypt from 'bcryptjs';

export const authOptions = {
  adapter: PrismaAdapter(prisma),
  providers: [
    CredentialsProvider({
      name: 'credentials',
      credentials: {
        username: { label: '用户名', type: 'text' },
        password: { label: '密码', type: 'password' }
      },
      async authorize(credentials) {
        if (!credentials?.username || !credentials?.password) {
          throw new Error('请输入用户名和密码');
        }

        const user = await prisma.user.findUnique({
          where: { username: credentials.username },
          include: { role: { include: { permissions: true } } }
        });

        if (!user) {
          await logLoginAttempt(null, false, credentials.username);
          throw new Error('用户名或密码错误');
        }

        // 检查账户是否锁定
        if (user.lockedUntil && user.lockedUntil > new Date()) {
          throw new Error(`账户已锁定，请在 ${user.lockedUntil.toLocaleString()} 后重试`);
        }

        const isValid = await bcrypt.compare(credentials.password, user.password);
        
        await logLoginAttempt(user.id, isValid, credentials.username, user);

        if (!isValid) {
          // 增加失败计数
          await prisma.user.update({
            where: { id: user.id },
            data: {
              loginAttempts: { increment: 1 },
              lockedUntil: user.loginAttempts >= 4 ? new Date(Date.now() + 30 * 60000) : null
            }
          });
          throw new Error('用户名或密码错误');
        }

        // 重置失败计数
        await prisma.user.update({
          where: { id: user.id },
          data: { loginAttempts: 0, lockedUntil: null, lastLogin: new Date() }
        });

        return {
          id: user.id,
          username: user.username,
          email: user.email,
          role: user.role.code,
          permissions: user.role.permissions
        };
      }
    })
  ],
  session: {
    strategy: 'database',
    maxAge: 8 * 60 * 60, // 8小时
  },
  callbacks: {
    async session({ session, user }) {
      if (session?.user) {
        session.user.id = user.id;
        session.user.role = user.role;
        session.user.permissions = user.permissions;
      }
      return session;
    }
  },
  pages: {
    signIn: '/admin/login',
  }
};

const handler = NextAuth(authOptions);
export { handler as GET, handler as POST };

async function logLoginAttempt(userId: string | null, success: boolean, username: string, user?: any) {
  await prisma.loginAttempt.create({
    data: {
      userId: userId || 'unknown',
      success,
      ip: headers().get('x-forwarded-for') || 'unknown',
      userAgent: headers().get('user-agent')
    }
  });
}
2.3.4 权限中间件
typescript
// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { getToken } from 'next-auth/jwt';

const protectedRoutes = [
  '/api/admin',
  '/api/reits',
  '/admin'
];

const publicRoutes = [
  '/admin/login',
  '/api/auth'
];

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  
  // 公开路由跳过
  if (publicRoutes.some(route => pathname.startsWith(route))) {
    return NextResponse.next();
  }
  
  // 检查是否受保护
  if (protectedRoutes.some(route => pathname.startsWith(route))) {
    const token = await getToken({ 
      req: request,
      secret: process.env.NEXTAUTH_SECRET 
    });
    
    if (!token) {
      // API请求返回401，页面请求重定向到登录
      if (pathname.startsWith('/api/')) {
        return NextResponse.json(
          { error: '未授权访问' },
          { status: 401 }
        );
      }
      return NextResponse.redirect(new URL('/admin/login', request.url));
    }
    
    // 检查具体权限（API路由）
    if (pathname.startsWith('/api/')) {
      const hasPermission = await checkPermission(token, pathname, request.method);
      if (!hasPermission) {
        return NextResponse.json(
          { error: '权限不足' },
          { status: 403 }
        );
      }
    }
  }
  
  return NextResponse.next();
}

async function checkPermission(token: any, path: string, method: string): Promise<boolean> {
  // 从路径和方法映射所需权限
  const permissionMap: Record<string, Record<string, string>> = {
    '/api/reits': {
      'GET': 'reit:view',
      'POST': 'reit:create',
      'PUT': 'reit:update',
      'DELETE': 'reit:delete'
    },
    '/api/users': {
      'GET': 'user:view',
      'POST': 'user:create',
      'PUT': 'user:update',
      'DELETE': 'user:delete'
    }
  };
  
  const basePath = Object.keys(permissionMap).find(key => path.startsWith(key));
  if (!basePath) return true;
  
  const required = permissionMap[basePath][method];
  if (!required) return true;
  
  return token.permissions?.some((p: any) => 
    p.resource === required.split(':')[0] && 
    p.action === required.split(':')[1]
  );
}