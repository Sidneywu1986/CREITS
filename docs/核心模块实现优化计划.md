# æ ¸å¿ƒæ¨¡å—å®ç°ä¼˜åŒ–è®¡åˆ’

## ğŸ“‹ å®ç°å¯¹æ¯”åˆ†æ

### 1. BBS ç­¾åæ¨¡å—

#### å½“å‰å®ç°ï¼ˆæ¨¡æ‹Ÿç‰ˆæœ¬ï¼‰
**æ–‡ä»¶**: `src/lib/encryption/bbs-signature.ts`

**ç‰¹ç‚¹**:
- âœ… æ¥å£è®¾è®¡å®Œæ•´
- âœ… æ¨¡æ‹Ÿå®ç°å¯ç”¨
- âš ï¸ ä¸æ˜¯çœŸå®çš„ BBS+ ç­¾å
- âš ï¸ ä»…ç”¨äºæ¼”ç¤ºå’Œå¼€å‘

**æ”¹è¿›æ–¹æ¡ˆ**:
```typescript
// é›†æˆçœŸå®çš„ @docknetwork/crypto-wasm åº“
pnpm add @docknetwork/crypto-wasm

// ä¼˜åŒ–åçš„å®ç°
import * as bbs from '@docknetwork/crypto-wasm';

// å»¶è¿ŸåŠ è½½ WASMï¼ˆé¿å…é¦–å±é˜»å¡ï¼‰
let initialized = false;
export const initBBS = async () => {
  if (!initialized) {
    await bbs.ready;
    initialized = true;
  }
};

export interface BBSCredential {
  messages: string[];
  signature: Uint8Array;
}

export const generateProof = async (
  credential: BBSCredential,
  disclosedIndices: number[]
) => {
  await initBBS();
  // è°ƒç”¨ WASM æ–¹æ³•ç”Ÿæˆé›¶çŸ¥è¯†è¯æ˜
  const proof = bbs.createProof(
    credential.messages,
    credential.signature,
    disclosedIndices
  );
  return proof;
};

export const verifyProof = async (
  proof: Uint8Array,
  publicKey: Uint8Array,
  disclosedMessages: string[],
  disclosedIndices: number[]
) => {
  await initBBS();
  return bbs.verifyProof(proof, publicKey, disclosedMessages, disclosedIndices);
};
```

**React Hook å°è£…**:
```typescript
import { useEffect, useState } from 'react';
import { generateProof, initBBS } from '@/lib/encryption/bbs-signature';

export const useBBS = () => {
  const [ready, setReady] = useState(false);
  const [loading, setLoading] = useState(false);
  
  useEffect(() => {
    initBBS().then(() => setReady(true));
  }, []);
  
  return { 
    ready, 
    loading,
    generateProof: async (...args: Parameters<typeof generateProof>) => {
      setLoading(true);
      try {
        return await generateProof(...args);
      } finally {
        setLoading(false);
      }
    }
  };
};
```

**æ”¹è¿›ç‚¹**:
- âœ… çœŸå® BBS+ ç­¾åç®—æ³•
- âœ… é›¶çŸ¥è¯†è¯æ˜åŠŸèƒ½
- âœ… å»¶è¿ŸåŠ è½½ä¼˜åŒ–
- âœ… React Hook å°è£…
- ğŸ”’ **æŠ—é‡å­æ”»å‡»** - åŸºäº BLS12-381 æ›²çº¿ï¼Œç¬¦åˆåé‡å­å®‰å…¨æ ‡å‡†
- ğŸ”’ **å®‰å…¨æ€§æµ‹è¯•** - éªŒè¯ç­¾åå¼ºåº¦ã€é›¶çŸ¥è¯†è¯æ˜æ­£ç¡®æ€§

**å®‰å…¨æ€§æµ‹è¯•éªŒè¯æ­¥éª¤**ï¼ˆWeek 1ï¼‰:
```typescript
/**
 * BBS ç­¾åå®‰å…¨æ€§æµ‹è¯•
 * éªŒè¯æŠ—é‡å­æ”»å‡»ç‰¹æ€§ï¼ˆåŸºäº BLS12-381 æ›²çº¿ï¼‰
 */
export async function testBBSSecurityStrength() {
  console.log('[Security Test] å¼€å§‹ BBS ç­¾åå®‰å…¨æ€§æµ‹è¯•...');

  // 1. æµ‹è¯•å¯†é’¥ç”Ÿæˆå¼ºåº¦
  const keypair = await generateKeypair();
  console.log('[Security Test] å¯†é’¥é•¿åº¦:', {
    publicKey: keypair.publicKey.length * 8, // bits
    secretKey: keypair.secretKey.length * 8, // bits
  });

  // BLS12-381 æ›²çº¿ç‰¹æ€§éªŒè¯
  const securityLevel = 128; // 128-bit å®‰å…¨çº§åˆ«
  const curveOrder = BigInt('0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001');
  console.log('[Security Test] æ›²çº¿ç‰¹æ€§:', {
    curve: 'BLS12-381',
    securityLevel: `${securityLevel}-bit`,
    curveOrder: curveOrder.toString(16),
  });

  // 2. æµ‹è¯•ç­¾åä¸å¯ä¼ªé€ æ€§
  const message = 'Test message for security verification';
  const signature = await sign(message, keypair.secretKey);
  
  // å°è¯•ä¼ªé€ ç­¾åï¼ˆåº”è¯¥å¤±è´¥ï¼‰
  const forgedSignature = new Uint8Array(signature.map(b => b ^ 0xFF));
  const isForgeryValid = await verify(message, forgedSignature, keypair.publicKey);
  
  console.log('[Security Test] ä¼ªé€ ç­¾åéªŒè¯:', {
    forgedSignature: Array.from(forgedSignature.slice(0, 16)).map(b => b.toString(16)).join(' '),
    isValid: isForgeryValid, // åº”è¯¥æ˜¯ false
    testPassed: !isForgeryValid,
  });

  // 3. æµ‹è¯•é›¶çŸ¥è¯†è¯æ˜çš„æ­£ç¡®æ€§
  const disclosedIndices = [0]; // æŠ«éœ²ç¬¬ä¸€æ¡æ¶ˆæ¯
  const proof = await createProof(
    [message],
    signature,
    disclosedIndices
  );
  
  const isProofValid = await verifyProof(
    proof,
    keypair.publicKey,
    [message],
    disclosedIndices
  );
  
  console.log('[Security Test] é›¶çŸ¥è¯†è¯æ˜éªŒè¯:', {
    proofLength: proof.length,
    isValid: isProofValid,
    disclosedCount: disclosedIndices.length,
    testPassed: isProofValid,
  });

  // 4. æµ‹è¯•é€‰æ‹©æ€§æŠ«éœ²
  const messages = ['msg1', 'msg2', 'msg3', 'msg4', 'msg5'];
  const multiSig = await sign(messages.join('|'), keypair.secretKey);
  
  // æŠ«éœ²ç¬¬ 2 å’Œç¬¬ 4 æ¡æ¶ˆæ¯
  const disclosedIndices2 = [1, 3];
  const proof2 = await createProof(
    messages,
    multiSig,
    disclosedIndices2
  );
  
  const isProofValid2 = await verifyProof(
    proof2,
    keypair.publicKey,
    messages,
    disclosedIndices2
  );
  
  console.log('[Security Test] é€‰æ‹©æ€§æŠ«éœ²éªŒè¯:', {
    totalMessages: messages.length,
    disclosedMessages: disclosedIndices2,
    isProofValid: isProofValid2,
    testPassed: isProofValid2,
  });

  // 5. æµ‹è¯•æŠ—é‡å­æ”»å‡»ç‰¹æ€§
  // BLS12-381 æ›²çº¿åœ¨é‡å­è®¡ç®—æœºä¸‹çš„æŠ—æ€§è¯„ä¼°
  const quantumResistance = {
    curve: 'BLS12-381',
    classicalSecurity: '128-bit',
    quantumSecurity: 'çº¦ 100-bit', // é‡å­è®¡ç®—ä¸‹çš„ç­‰æ•ˆå®‰å…¨æ€§
    postQuantumReady: true,
    migrationPath: 'å¯è¿ç§»åˆ°åé‡å­å¯†ç å­¦',
  };
  
  console.log('[Security Test] æŠ—é‡å­æ”»å‡»ç‰¹æ€§:', quantumResistance);

  // 6. æ€§èƒ½æµ‹è¯•ï¼ˆç¡®ä¿å®‰å…¨æ€§ä¸å½±å“å¯ç”¨æ€§ï¼‰
  const iterations = 100;
  const start = performance.now();
  
  for (let i = 0; i < iterations; i++) {
    const testMessage = `Test message ${i}`;
    const testSig = await sign(testMessage, keypair.secretKey);
    await verify(testMessage, testSig, keypair.publicKey);
  }
  
  const duration = performance.now() - start;
  const avgTime = duration / iterations;
  
  console.log('[Security Test] æ€§èƒ½æµ‹è¯•:', {
    iterations,
    totalTime: duration.toFixed(2),
    avgTime: avgTime.toFixed(2),
    acceptable: avgTime < 100, // å¹³å‡æ¯æ¬¡ < 100ms
    testPassed: avgTime < 100,
  });

  console.log('[Security Test] âœ… æ‰€æœ‰å®‰å…¨æ€§æµ‹è¯•å®Œæˆ');
  return {
    securityLevel: `${securityLevel}-bit`,
    quantumResistance: quantumResistance.quantumSecurity,
    performance: `${avgTime.toFixed(2)}ms/op`,
  };
}
```

**å®‰å…¨æ€§æµ‹è¯•é¢„æœŸç»“æœ**:
```
[Security Test] å¯†é’¥é•¿åº¦: { publicKey: 768, secretKey: 768 }
[Security Test] æ›²çº¿ç‰¹æ€§: { curve: 'BLS12-381', securityLevel: '128-bit' }
[Security Test] ä¼ªé€ ç­¾åéªŒè¯: { isValid: false, testPassed: true }
[Security Test] é›¶çŸ¥è¯†è¯æ˜éªŒè¯: { isValid: true, testPassed: true }
[Security Test] é€‰æ‹©æ€§æŠ«éœ²éªŒè¯: { isProofValid: true, testPassed: true }
[Security Test] æŠ—é‡å­æ”»å‡»ç‰¹æ€§: { quantumSecurity: 'çº¦ 100-bit', postQuantumReady: true }
[Security Test] æ€§èƒ½æµ‹è¯•: { avgTime: '15.23ms/op', acceptable: true, testPassed: true }
```

---

### 2. ä¹¦å¯†ç åŠ å¯†æ¨¡å—

#### å½“å‰å®ç°
**æ–‡ä»¶**: `src/lib/encryption/book-cipher.ts`

**ç‰¹ç‚¹**:
- âœ… ä½¿ç”¨ Web Crypto API
- âœ… AES-GCM åŠ å¯†
- âœ… PBKDF2 å¯†é’¥æ´¾ç”Ÿ
- âœ… æ”¯æŒä½ç½®ç´¢å¼•

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```typescript
export class BookCipher {
  private book: Uint8Array;
  constructor(bookContent: string | ArrayBuffer) {
    this.book = typeof bookContent === 'string' 
      ? new TextEncoder().encode(bookContent)
      : new Uint8Array(bookContent);
  }

  async encrypt(plainText: string, startPos: number) {
    // ä»ä¹¦æœ¬ä¸­æå–å¯†é’¥
    const keyStream = this.extractKeyStream(startPos, plainText.length);
    
    // ä½¿ç”¨ HMAC-SHA256 æ´¾ç”Ÿå¯†é’¥
    const key = await this.deriveKey(keyStream);
    
    // AES-GCM åŠ å¯†
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encrypted = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv },
      key,
      new TextEncoder().encode(plainText)
    );
    
    // ç»„åˆ IV å’Œå¯†æ–‡
    const combined = new Uint8Array(iv.length + encrypted.byteLength);
    combined.set(iv);
    combined.set(new Uint8Array(encrypted), iv.length);
    
    return btoa(String.fromCharCode(...combined));
  }

  async decrypt(cipherBase64: string, startPos: number, length: number) {
    const combined = Uint8Array.from(atob(cipherBase64), c => c.charCodeAt(0));
    const iv = combined.slice(0, 12);
    const encrypted = combined.slice(12);
    
    const keyStream = this.extractKeyStream(startPos, length);
    const key = await this.deriveKey(keyStream);
    
    const decrypted = await crypto.subtle.decrypt(
      { name: 'AES-GCM', iv },
      key,
      encrypted
    );
    
    return new TextDecoder().decode(decrypted);
  }

  private async deriveKey(keyStream: Uint8Array): Promise<CryptoKey> {
    const keyMaterial = await crypto.subtle.importKey(
      'raw',
      keyStream,
      'PBKDF2',
      false,
      ['deriveKey']
    );
    
    const salt = new TextEncoder().encode('REITs-BOOK-CIPHER-SALT');
    
    return crypto.subtle.deriveKey(
      {
        name: 'PBKDF2',
        salt,
        iterations: 100000,
        hash: 'SHA-256'
      },
      keyMaterial,
      { name: 'AES-GCM', length: 256 },
      false,
      ['encrypt', 'decrypt']
    );
  }

  private extractKeyStream(startPos: number, length: number): Uint8Array {
    const endPos = Math.min(startPos + length * 32, this.book.length);
    return this.book.slice(startPos, endPos);
  }

  generateStartPos(): number {
    return Math.floor(Math.random() * (this.book.length - 256));
  }
}
```

**æ”¹è¿›ç‚¹**:
- âœ… ä¼˜åŒ–å¯†é’¥æ´¾ç”Ÿ
- âœ… æ”¯æŒ ArrayBuffer è¾“å…¥
- âœ… æ›´å®‰å…¨çš„å¯†é’¥æµæå–
- âœ… å›ºå®šç›å€¼ï¼ˆå®é™…åº”ç”¨åº”éšæœºï¼‰
- ğŸ”’ **æ–‡ä»¶å“ˆå¸Œæ ¸å¯¹** - ç¡®ä¿ä¹¦æœ¬æ–‡ä»¶å®Œæ•´æ€§
- ğŸ”’ **å¤‡ä»½æé†’** - è‡ªåŠ¨æé†’ç”¨æˆ·å¤‡ä»½ä¹¦æœ¬æ–‡ä»¶

**å¯†é’¥ç®¡ç†å¢å¼ºæ–¹æ¡ˆ**:

```typescript
/**
 * ä¹¦æœ¬æ–‡ä»¶å“ˆå¸Œè®¡ç®—å’ŒéªŒè¯
 */
export class BookFileValidator {
  /**
   * è®¡ç®—ä¹¦æœ¬æ–‡ä»¶çš„ SHA-256 å“ˆå¸Œå€¼
   */
  static async calculateHash(file: File | ArrayBuffer | string): Promise<string> {
    let buffer: ArrayBuffer;

    if (file instanceof File) {
      buffer = await file.arrayBuffer();
    } else if (typeof file === 'string') {
      buffer = new TextEncoder().encode(file).buffer;
    } else {
      buffer = file;
    }

    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  }

  /**
   * éªŒè¯ä¹¦æœ¬æ–‡ä»¶å“ˆå¸Œ
   */
  static async verifyHash(
    file: File | ArrayBuffer | string,
    expectedHash: string
  ): Promise<{ valid: boolean; actualHash: string }> {
    const actualHash = await this.calculateHash(file);
    return {
      valid: actualHash.toLowerCase() === expectedHash.toLowerCase(),
      actualHash,
    };
  }

  /**
   * ç”Ÿæˆä¹¦æœ¬æ–‡ä»¶çš„æŒ‡çº¹ï¼ˆåŒ…å«å¤§å°ã€ç±»å‹ã€å“ˆå¸Œï¼‰
   */
  static async generateFingerprint(file: File): Promise<{
    name: string;
    size: number;
    type: string;
    hash: string;
    fingerprint: string;
  }> {
    const hash = await this.calculateHash(file);
    const fingerprint = `${file.name}-${file.size}-${hash.substring(0, 16)}`;
    
    return {
      name: file.name,
      size: file.size,
      type: file.type,
      hash,
      fingerprint,
    };
  }
}

/**
 * ä¹¦æœ¬æ–‡ä»¶å¤‡ä»½ç®¡ç†å™¨
 */
export class BookBackupManager {
  private static readonly BACKUP_KEY = 'book_backup_reminders';
  private static readonly BACKUP_INTERVAL = 30 * 24 * 60 * 60 * 1000; // 30å¤©

  /**
   * è®°å½•ä¹¦æœ¬æ–‡ä»¶ä¸Šä¼ æ—¶é—´
   */
  static async recordBookUpload(bookId: string, bookName: string): Promise<void> {
    const db = await getDB();
    const backupData = {
      bookId,
      bookName,
      uploadTime: Date.now(),
      lastBackupReminder: Date.now(),
    };
    await db.put('books', backupData, `backup_${bookId}`);
  }

  /**
   * æ£€æŸ¥æ˜¯å¦éœ€è¦æé†’ç”¨æˆ·å¤‡ä»½
   */
  static async checkBackupReminder(bookId: string): Promise<boolean> {
    const db = await getDB();
    const backupData = await db.get('books', `backup_${bookId}`);
    
    if (!backupData) return false;
    
    const now = Date.now();
    const timeSinceLastReminder = now - backupData.lastBackupReminder;
    
    return timeSinceLastReminder >= this.BACKUP_INTERVAL;
  }

  /**
   * æ›´æ–°å¤‡ä»½æé†’æ—¶é—´
   */
  static async updateBackupReminder(bookId: string): Promise<void> {
    const db = await getDB();
    const backupData = await db.get('books', `backup_${bookId}`);
    
    if (backupData) {
      backupData.lastBackupReminder = Date.now();
      await db.put('books', backupData, `backup_${bookId}`);
    }
  }

  /**
   * è·å–æ‰€æœ‰éœ€è¦å¤‡ä»½æé†’çš„ä¹¦æœ¬æ–‡ä»¶
   */
  static async getBackupReminders(): Promise<Array<{
    bookId: string;
    bookName: string;
    uploadTime: number;
    daysSinceUpload: number;
  }>> {
    const db = await getDB();
    const books = await db.getAll('books');
    
    const now = Date.now();
    return books
      .filter((book: any) => book.bookId && book.uploadTime)
      .map((book: any) => ({
        bookId: book.bookId,
        bookName: book.name || 'Unknown',
        uploadTime: book.uploadTime,
        daysSinceUpload: Math.floor((now - book.uploadTime) / (24 * 60 * 60 * 1000)),
      }))
      .filter((book) => book.daysSinceUpload >= 30);
  }
}

/**
 * UI ç»„ä»¶ï¼šä¹¦æœ¬æ–‡ä»¶ä¸Šä¼ å’ŒéªŒè¯
 */
export function BookFileUploader({
  onFileSelect,
  onHashVerify,
}: {
  onFileSelect: (file: File, hash: string) => void;
  onHashVerify: (valid: boolean) => void;
}) {
  const [file, setFile] = useState<File | null>(null);
  const [hash, setHash] = useState<string>('');
  const [verifying, setVerifying] = useState(false);
  const [showBackupReminder, setShowBackupReminder] = useState(false);

  const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const selectedFile = e.target.files?.[0];
    if (!selectedFile) return;

    setVerifying(true);
    setFile(selectedFile);

    try {
      // è®¡ç®—æ–‡ä»¶å“ˆå¸Œ
      const calculatedHash = await BookFileValidator.calculateHash(selectedFile);
      setHash(calculatedHash);

      // éªŒè¯æ–‡ä»¶å®Œæ•´æ€§
      const fingerprint = await BookFileValidator.generateFingerprint(selectedFile);
      
      onFileSelect(selectedFile, calculatedHash);
      
      // æ£€æŸ¥æ˜¯å¦éœ€è¦å¤‡ä»½æé†’
      const needsBackup = await BookBackupManager.checkBackupReminder(
        fingerprint.fingerprint
      );
      if (needsBackup) {
        setShowBackupReminder(true);
      }

      toast.success('ä¹¦æœ¬æ–‡ä»¶ä¸Šä¼ æˆåŠŸ', {
        description: `æ–‡ä»¶å“ˆå¸Œ: ${calculatedHash.substring(0, 16)}...`,
      });
    } catch (error) {
      toast.error('æ–‡ä»¶éªŒè¯å¤±è´¥', {
        description: error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯',
      });
    } finally {
      setVerifying(false);
    }
  };

  return (
    <div className="space-y-4">
      <div>
        <Label htmlFor="book-file">ä¸Šä¼ ä¹¦æœ¬æ–‡ä»¶</Label>
        <Input
          id="book-file"
          type="file"
          accept=".txt,.pdf"
          onChange={handleFileChange}
          disabled={verifying}
        />
        {verifying && (
          <p className="text-sm text-muted-foreground mt-2">
            æ­£åœ¨éªŒè¯æ–‡ä»¶å®Œæ•´æ€§...
          </p>
        )}
      </div>

      {file && hash && (
        <Alert>
          <CheckCircle2 className="h-4 w-4" />
          <AlertDescription>
            <div className="space-y-1">
              <p><strong>æ–‡ä»¶å:</strong> {file.name}</p>
              <p><strong>æ–‡ä»¶å¤§å°:</strong> {(file.size / 1024 / 1024).toFixed(2)} MB</p>
              <p><strong>æ–‡ä»¶å“ˆå¸Œ:</strong> {hash}</p>
              <p className="text-xs text-muted-foreground">
                è¯·å¦¥å–„ä¿å­˜æ­¤å“ˆå¸Œå€¼ï¼Œç”¨äºéªŒè¯æ–‡ä»¶å®Œæ•´æ€§
              </p>
            </div>
          </AlertDescription>
        </Alert>
      )}

      {showBackupReminder && (
        <Alert>
          <ShieldAlert className="h-4 w-4" />
          <AlertDescription>
            <div className="space-y-2">
              <p><strong>å¤‡ä»½æé†’:</strong></p>
              <p className="text-sm">
                æ‚¨çš„ä¹¦æœ¬æ–‡ä»¶å·²ç»ä½¿ç”¨äº†ä¸€æ®µæ—¶é—´ï¼Œå»ºè®®æ‚¨ï¼š
              </p>
              <ul className="text-sm list-disc list-inside space-y-1">
                <li>å¤‡ä»½åŸå§‹ä¹¦æœ¬æ–‡ä»¶åˆ°å®‰å…¨ä½ç½®</li>
                <li>è®°å½•æ–‡ä»¶å“ˆå¸Œå€¼ä»¥ä¾¿éªŒè¯</li>
                <li>å®šæœŸæ£€æŸ¥æ–‡ä»¶å®Œæ•´æ€§</li>
              </ul>
              <Button
                size="sm"
                onClick={() => setShowBackupReminder(false)}
              >
                æˆ‘å·²å¤‡ä»½
              </Button>
            </div>
          </AlertDescription>
        </Alert>
      )}
    </div>
  );
}
```

**å¯†é’¥ç®¡ç†æœ€ä½³å®è·µ**:
1. **æ–‡ä»¶å“ˆå¸Œæ ¸å¯¹** - æ¯æ¬¡ä½¿ç”¨ä¹¦æœ¬æ–‡ä»¶æ—¶éªŒè¯ SHA-256 å“ˆå¸Œ
2. **å®šæœŸå¤‡ä»½æé†’** - æ¯30å¤©æé†’ç”¨æˆ·å¤‡ä»½åŸå§‹æ–‡ä»¶
3. **å®Œæ•´æ€§æ£€æŸ¥** - å®šæœŸéªŒè¯ä¹¦æœ¬æ–‡ä»¶æœªè¢«ç¯¡æ”¹
4. **å®‰å…¨å­˜å‚¨** - ä¹¦æœ¬æ–‡ä»¶å­˜å‚¨åœ¨åŠ å¯†çš„ IndexedDB ä¸­
5. **å¤šé‡éªŒè¯** - ç»“åˆæ–‡ä»¶åã€å¤§å°ã€å“ˆå¸Œå¤šé‡éªŒè¯

**ç”¨æˆ·ä½“éªŒå¢å¼º**:
- âœ… ä¸Šä¼ æ—¶è‡ªåŠ¨è®¡ç®—å“ˆå¸Œ
- âœ… æ˜¾ç¤ºæ–‡ä»¶æŒ‡çº¹ä¿¡æ¯
- âœ… å®šæœŸå¤‡ä»½æé†’
- âœ… å®Œæ•´æ€§æ£€æŸ¥æŒ‰é’®
- âœ… å¤‡ä»½å¯¼å‡ºåŠŸèƒ½

---

### 3. IndexedDB å­˜å‚¨

#### å½“å‰å®ç°
**æ–‡ä»¶**: `src/lib/storage/indexeddb.ts`

**ç‰¹ç‚¹**:
- âœ… å®Œæ•´çš„ IndexedDB å°è£…
- âœ… æ”¯æŒå¤šç§å¯¹è±¡å­˜å‚¨
- âœ… ç¼“å­˜åŠŸèƒ½
- âš ï¸ ä»£ç è¾ƒä¸ºå¤æ‚

**ç®€åŒ–æ–¹æ¡ˆ**:
```typescript
import { openDB, DBSchema, IDBPDatabase } from 'idb';

interface REITsBBSDB extends DBSchema {
  credentials: {
    key: string;
    value: {
      userId: string;
      publicKey: string;
      secretKey: string;
      anonymousId: string;
    };
  };
  books: {
    key: string;
    value: {
      bookId: string;
      name: string;
      content: ArrayBuffer;
      fingerprint: string;
    };
  };
}

const DB_NAME = 'reits-bbs-db';
const DB_VERSION = 1;

let db: IDBPDatabase<REITsBBSDB> | null = null;

export const getDB = async () => {
  if (db) return db;
  
  db = await openDB<REITsBBSDB>(DB_NAME, DB_VERSION, {
    upgrade(db) {
      if (!db.objectStoreNames.contains('credentials')) {
        db.createObjectStore('credentials');
      }
      if (!db.objectStoreNames.contains('books')) {
        db.createObjectStore('books');
      }
    },
  });
  
  return db;
};

export const saveCredential = async (userId: string, credential: any) => {
  const database = await getDB();
  await database.put('credentials', credential, userId);
};

export const getCredential = async (userId: string) => {
  const database = await getDB();
  return database.get('credentials', userId);
};

export const saveBook = async (bookId: string, book: any) => {
  const database = await getDB();
  await database.put('books', book, bookId);
};

export const getBook = async (bookId: string) => {
  const database = await getDB();
  return database.get('books', bookId);
};
```

**æ”¹è¿›ç‚¹**:
- âœ… ä»£ç æ›´ç®€æ´
- âœ… å•ä¾‹æ¨¡å¼ä¼˜åŒ–
- âœ… TypeScript ç±»å‹å®‰å…¨
- âœ… æ›´æ˜“ç»´æŠ¤

---

### 4. API å®¢æˆ·ç«¯

#### å½“å‰å®ç°
**æ–‡ä»¶**: `src/lib/api/client.ts`

**ç‰¹ç‚¹**:
- âœ… ç»Ÿä¸€çš„ API å®¢æˆ·ç«¯
- âœ… è‡ªåŠ¨æ³¨å…¥è®¤è¯å¤´
- âœ… é”™è¯¯å¤„ç†
- âœ… æ–‡ä»¶ä¸Šä¼ æ”¯æŒ

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```typescript
import { getAnonymousId } from '@/stores/userStore';

const API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL || '/api/v1';

export const apiClient = {
  async get<T>(url: string, config?: RequestInit): Promise<T> {
    const headers = await getAuthHeaders();
    const res = await fetch(`${API_BASE}${url}`, { ...config, headers });
    if (!res.ok) throw new Error(await res.text());
    return res.json();
  },

  async post<T>(url: string, data?: any, config?: RequestInit): Promise<T> {
    const headers = await getAuthHeaders();
    const res = await fetch(`${API_BASE}${url}`, {
      method: 'POST',
      headers,
      body: JSON.stringify(data),
      ...config
    });
    if (!res.ok) throw new Error(await res.text());
    return res.json();
  },

  async put<T>(url: string, data?: any, config?: RequestInit): Promise<T> {
    const headers = await getAuthHeaders();
    const res = await fetch(`${API_BASE}${url}`, {
      method: 'PUT',
      headers,
      body: JSON.stringify(data),
      ...config
    });
    if (!res.ok) throw new Error(await res.text());
    return res.json();
  },

  async delete<T>(url: string, config?: RequestInit): Promise<T> {
    const headers = await getAuthHeaders();
    const res = await fetch(`${API_BASE}${url}`, {
      method: 'DELETE',
      headers,
      ...config
    });
    if (!res.ok) throw new Error(await res.text());
    return res.json();
  },
};

async function getAuthHeaders() {
  const anonymousId = getAnonymousId();
  return {
    'Content-Type': 'application/json',
    ...(anonymousId && { 'X-Anonymous-ID': anonymousId }),
  };
}
```

**æ”¹è¿›ç‚¹**:
- âœ… ä»£ç æ›´ç®€æ´
- âœ… ç±»å‹å®‰å…¨
- âœ… ç»Ÿä¸€é”™è¯¯å¤„ç†
- âœ… æ”¯æŒè‡ªå®šä¹‰é…ç½®
- ğŸ”’ **å…¨å±€é”™è¯¯å¤„ç†** - 401è·³è½¬ç™»å½•ã€500å±•ç¤ºå‹å¥½æç¤º
- ğŸ”’ **é”™è¯¯æ¢å¤æœºåˆ¶** - è‡ªåŠ¨é‡è¯•ã€é™çº§ç­–ç•¥

**å…¨å±€é”™è¯¯å¤„ç†å¢å¼ºæ–¹æ¡ˆ**:

```typescript
/**
 * é”™è¯¯ç±»å‹å®šä¹‰
 */
export enum ErrorCode {
  UNAUTHORIZED = 401,
  FORBIDDEN = 403,
  NOT_FOUND = 404,
  SERVER_ERROR = 500,
  NETWORK_ERROR = 'NETWORK_ERROR',
  TIMEOUT_ERROR = 'TIMEOUT_ERROR',
  VALIDATION_ERROR = 'VALIDATION_ERROR',
}

export interface ApiError {
  code: ErrorCode;
  message: string;
  details?: any;
  timestamp: number;
}

/**
 * å…¨å±€é”™è¯¯å¤„ç†å™¨
 */
class GlobalErrorHandler {
  private static instance: GlobalErrorHandler;
  private errorCallbacks: Map<ErrorCode, (error: ApiError) => void> = new Map();

  private constructor() {
    this.setupDefaultHandlers();
  }

  static getInstance(): GlobalErrorHandler {
    if (!GlobalErrorHandler.instance) {
      GlobalErrorHandler.instance = new GlobalErrorHandler();
    }
    return GlobalErrorHandler.instance;
  }

  /**
   * è®¾ç½®é»˜è®¤çš„é”™è¯¯å¤„ç†å™¨
   */
  private setupDefaultHandlers() {
    // 401 æœªæˆæƒ - è·³è½¬ç™»å½•
    this.registerHandler(ErrorCode.UNAUTHORIZED, (error) => {
      console.error('[Global Error] Unauthorized:', error);
      toast.error('ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•');
      useUserStore.getState().logout();
      window.location.href = '/login';
    });

    // 403 ç¦æ­¢è®¿é—®
    this.registerHandler(ErrorCode.FORBIDDEN, (error) => {
      console.error('[Global Error] Forbidden:', error);
      toast.error('æ‚¨æ²¡æœ‰æƒé™æ‰§è¡Œæ­¤æ“ä½œ');
    });

    // 404 èµ„æºä¸å­˜åœ¨
    this.registerHandler(ErrorCode.NOT_FOUND, (error) => {
      console.error('[Global Error] Not Found:', error);
      toast.error('è¯·æ±‚çš„èµ„æºä¸å­˜åœ¨');
    });

    // 500 æœåŠ¡å™¨é”™è¯¯
    this.registerHandler(ErrorCode.SERVER_ERROR, (error) => {
      console.error('[Global Error] Server Error:', error);
      toast.error('æœåŠ¡å™¨é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•', {
        description: error.details || 'ç³»ç»Ÿæ­£åœ¨å¤„ç†æ‚¨çš„è¯·æ±‚',
        action: {
          label: 'é‡è¯•',
          onClick: () => window.location.reload(),
        },
      });
    });

    // ç½‘ç»œé”™è¯¯
    this.registerHandler(ErrorCode.NETWORK_ERROR, (error) => {
      console.error('[Global Error] Network Error:', error);
      toast.error('ç½‘ç»œè¿æ¥å¤±è´¥', {
        description: 'è¯·æ£€æŸ¥æ‚¨çš„ç½‘ç»œè¿æ¥',
        action: {
          label: 'é‡è¯•',
          onClick: () => window.location.reload(),
        },
      });
    });

    // è¶…æ—¶é”™è¯¯
    this.registerHandler(ErrorCode.TIMEOUT_ERROR, (error) => {
      console.error('[Global Error] Timeout Error:', error);
      toast.error('è¯·æ±‚è¶…æ—¶', {
        description: 'è¯·ç¨åé‡è¯•',
        action: {
          label: 'é‡è¯•',
          onClick: () => window.location.reload(),
        },
      });
    });
  }

  /**
   * æ³¨å†Œè‡ªå®šä¹‰é”™è¯¯å¤„ç†å™¨
   */
  registerHandler(code: ErrorCode, callback: (error: ApiError) => void) {
    this.errorCallbacks.set(code, callback);
  }

  /**
   * å¤„ç†é”™è¯¯
   */
  handleError(error: ApiError) {
    const handler = this.errorCallbacks.get(error.code);
    if (handler) {
      handler(error);
    } else {
      // é»˜è®¤å¤„ç†å™¨
      console.error('[Global Error] Unhandled error:', error);
      toast.error('å‘ç”Ÿé”™è¯¯', {
        description: error.message || 'æœªçŸ¥é”™è¯¯',
      });
    }
  }

  /**
   * æ¸…é™¤æ‰€æœ‰é”™è¯¯å¤„ç†å™¨
   */
  clearHandlers() {
    this.errorCallbacks.clear();
  }
}

/**
 * å¢å¼ºçš„ API å®¢æˆ·ç«¯ï¼ˆå¸¦å…¨å±€é”™è¯¯å¤„ç†ï¼‰
 */
const MAX_RETRIES = 3;
const RETRY_DELAY = 1000;
const TIMEOUT_MS = 30000;

export const apiClient = {
  async get<T>(url: string, config?: RequestInit): Promise<T> {
    return this.request<T>('GET', url, undefined, config);
  },

  async post<T>(url: string, data?: any, config?: RequestInit): Promise<T> {
    return this.request<T>('POST', url, data, config);
  },

  async put<T>(url: string, data?: any, config?: RequestInit): Promise<T> {
    return this.request<T>('PUT', url, data, config);
  },

  async delete<T>(url: string, config?: RequestInit): Promise<T> {
    return this.request<T>('DELETE', url, undefined, config);
  },

  /**
   * ç»Ÿä¸€çš„è¯·æ±‚æ–¹æ³•ï¼ˆå¸¦é‡è¯•å’Œé”™è¯¯å¤„ç†ï¼‰
   */
  private async request<T>(
    method: string,
    url: string,
    data?: any,
    config?: RequestInit,
    retries = MAX_RETRIES
  ): Promise<T> {
    const headers = await getAuthHeaders();
    const errorHandler = GlobalErrorHandler.getInstance();

    try {
      // åˆ›å»º AbortController ç”¨äºè¶…æ—¶æ§åˆ¶
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), TIMEOUT_MS);

      const response = await fetch(`${API_BASE}${url}`, {
        method,
        headers,
        body: data ? JSON.stringify(data) : undefined,
        signal: controller.signal,
        ...config,
      });

      clearTimeout(timeoutId);

      // å¤„ç†å“åº”
      if (!response.ok) {
        const apiError: ApiError = {
          code: response.status as ErrorCode,
          message: await response.text(),
          timestamp: Date.now(),
        };

        // ç‰¹å®šçŠ¶æ€ç ä¸é‡è¯•
        if ([401, 403, 404].includes(response.status)) {
          errorHandler.handleError(apiError);
          throw apiError;
        }

        // 5xx é”™è¯¯é‡è¯•
        if (response.status >= 500 && retries > 0) {
          console.warn(`[API Client] Retry ${MAX_RETRIES - retries + 1}/${MAX_RETRIES}`);
          await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));
          return this.request<T>(method, url, data, config, retries - 1);
        }

        errorHandler.handleError(apiError);
        throw apiError;
      }

      return response.json();
    } catch (error) {
      // å¤„ç† AbortErrorï¼ˆè¶…æ—¶ï¼‰
      if (error instanceof Error && error.name === 'AbortError') {
        const timeoutError: ApiError = {
          code: ErrorCode.TIMEOUT_ERROR,
          message: 'è¯·æ±‚è¶…æ—¶',
          timestamp: Date.now(),
        };
        errorHandler.handleError(timeoutError);
        throw timeoutError;
      }

      // å¤„ç†ç½‘ç»œé”™è¯¯
      if (error instanceof TypeError && error.message.includes('fetch')) {
        const networkError: ApiError = {
          code: ErrorCode.NETWORK_ERROR,
          message: 'ç½‘ç»œè¿æ¥å¤±è´¥',
          timestamp: Date.now(),
        };
        
        // ç½‘ç»œé”™è¯¯é‡è¯•
        if (retries > 0) {
          console.warn(`[API Client] Retry ${MAX_RETRIES - retries + 1}/${MAX_RETRIES}`);
          await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));
          return this.request<T>(method, url, data, config, retries - 1);
        }
        
        errorHandler.handleError(networkError);
        throw networkError;
      }

      // é‡æ–°æŠ›å‡ºå…¶ä»–é”™è¯¯
      throw error;
    }
  },
};

/**
 * React Hookï¼šé”™è¯¯è¾¹ç•Œ
 */
export function useErrorHandler() {
  const router = useRouter();

  const handleError = (error: ApiError) => {
    const errorHandler = GlobalErrorHandler.getInstance();
    errorHandler.handleError(error);
  };

  return { handleError };
}

/**
 * é«˜é˜¶ç»„ä»¶ï¼šé”™è¯¯è¾¹ç•Œ
 */
export function withErrorBoundary<P extends object>(
  Component: React.ComponentType<P>,
  fallback?: React.ReactNode
) {
  return function ErrorBoundaryWrapper(props: P) {
    return (
      <ErrorBoundary fallback={fallback}>
        <Component {...props} />
      </ErrorBoundary>
    );
  };
}
```

**å…¨å±€é”™è¯¯å¤„ç†ç‰¹æ€§**:
1. **401 æœªæˆæƒ** - è‡ªåŠ¨è·³è½¬ç™»å½•é¡µé¢
2. **403 ç¦æ­¢è®¿é—®** - æ˜¾ç¤ºæƒé™é”™è¯¯æç¤º
3. **404 èµ„æºä¸å­˜åœ¨** - æ˜¾ç¤ºå‹å¥½æç¤º
4. **500 æœåŠ¡å™¨é”™è¯¯** - æ˜¾ç¤ºé”™è¯¯å¹¶æä¾›é‡è¯•æŒ‰é’®
5. **ç½‘ç»œé”™è¯¯** - æ£€æµ‹ç½‘ç»œè¿æ¥å¹¶æä¾›é‡è¯•
6. **è¶…æ—¶é”™è¯¯** - 30ç§’è¶…æ—¶è‡ªåŠ¨é‡è¯•
7. **è‡ªåŠ¨é‡è¯•** - 5xx é”™è¯¯å’Œç½‘ç»œé”™è¯¯è‡ªåŠ¨é‡è¯•3æ¬¡
8. **é”™è¯¯æ—¥å¿—** - æ‰€æœ‰é”™è¯¯è®°å½•åˆ°æ§åˆ¶å°
9. **é™çº§ç­–ç•¥** - å…³é”®é”™è¯¯æ—¶æä¾›é™çº§æ–¹æ¡ˆ
10. **ç”¨æˆ·åé¦ˆ** - é€šè¿‡ Toast æä¾›å‹å¥½çš„é”™è¯¯åé¦ˆ

**é”™è¯¯å¤„ç†æµç¨‹**:
```
è¯·æ±‚ â†’ æ£€æŸ¥å“åº”çŠ¶æ€ç  â†’ é”™è¯¯åˆ†ç±» â†’ è°ƒç”¨å¯¹åº”å¤„ç†å™¨ â†’ ç”¨æˆ·åé¦ˆ
     â†“                                         â†“
  è‡ªåŠ¨é‡è¯•ï¼ˆ5xx/ç½‘ç»œé”™è¯¯ï¼‰              è®°å½•é”™è¯¯æ—¥å¿—
     â†“                                         â†“
  é‡è¯•å¤±è´¥ â†’ é™çº§ç­–ç•¥ â†’ æç¤ºç”¨æˆ·
```

---

### 5. ç”¨æˆ· Store

#### å½“å‰å®ç°
**æ–‡ä»¶**: `src/stores/userStore.ts`

**ç‰¹ç‚¹**:
- âœ… å®Œæ•´çš„ç”¨æˆ·çŠ¶æ€ç®¡ç†
- âœ… ç§¯åˆ†ç®¡ç†
- âœ… localStorage æŒä¹…åŒ–
- âœ… å®Œæ•´çš„ç±»å‹å®šä¹‰

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface UserState {
  anonymousId: string | null;
  publicKey: string | null;
  secretKey: string | null;
  points: number;
  isLoggedIn: boolean;
  
  // Actions
  setAnonymousId: (id: string) => void;
  setCredentials: (credentials: { publicKey: string; secretKey: string }) => void;
  updatePoints: (delta: number) => void;
  logout: () => void;
}

export const useUserStore = create<UserState>()(
  persist(
    (set) => ({
      anonymousId: null,
      publicKey: null,
      secretKey: null,
      points: 0,
      isLoggedIn: false,
      
      setAnonymousId: (id) => set({ 
        anonymousId: id,
        isLoggedIn: !!id 
      }),
      
      setCredentials: (credentials) => set({
        publicKey: credentials.publicKey,
        secretKey: credentials.secretKey,
      }),
      
      updatePoints: (delta) => set((state) => ({ 
        points: Math.max(0, state.points + delta) 
      })),
      
      logout: () => set({
        anonymousId: null,
        publicKey: null,
        secretKey: null,
        points: 0,
        isLoggedIn: false,
      }),
    }),
    {
      name: 'user-storage',
      partialize: (state) => ({
        anonymousId: state.anonymousId,
        publicKey: state.publicKey,
        secretKey: state.secretKey,
        points: state.points,
        isLoggedIn: state.isLoggedIn,
      }),
    }
  )
);

// Selectors
export const selectAnonymousId = (state: UserState) => state.anonymousId;
export const selectPoints = (state: UserState) => state.points;
export const selectIsLoggedIn = (state: UserState) => state.isLoggedIn;
```

**æ”¹è¿›ç‚¹**:
- âœ… ä»£ç æ›´ç®€æ´
- âœ… æ·»åŠ  Selector ä¼˜åŒ–
- âœ… ç§¯åˆ†ä¸èƒ½ä¸ºè´Ÿæ•°
- âœ… æ›´å¥½çš„æŒä¹…åŒ–ç­–ç•¥

---

### 6. BBS å¸–å­åˆ—è¡¨é¡µé¢

#### å½“å‰å®ç°
**æ–‡ä»¶**: `pages/bbs/index.tsx`

**ç‰¹ç‚¹**:
- âœ… å®Œæ•´çš„å¸–å­åˆ—è¡¨
- âœ… åˆ†ç±»ç­›é€‰
- âœ… æœç´¢åŠŸèƒ½
- âœ… åˆ†é¡µåŠ è½½
- âœ… å“åº”å¼è®¾è®¡

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```tsx
import { useQuery } from '@tanstack/react-query';
import { apiClient } from '@/lib/api/client';
import { useUserStore } from '@/stores/userStore';
import { Card } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';

export default function BBSPage() {
  const { anonymousId } = useUserStore();
  
  const { data, isLoading, error } = useQuery({
    queryKey: ['posts'],
    queryFn: () => apiClient.get('/posts'),
    enabled: !!anonymousId, // åªæœ‰ç™»å½•åæ‰è·å–æ•°æ®
  });

  if (isLoading) return <div>åŠ è½½ä¸­...</div>;
  if (error) return <div>åŠ è½½å¤±è´¥: {error.message}</div>;

  return (
    <div className="container mx-auto p-4 max-w-6xl">
      <div className="flex items-center justify-between mb-6">
        <h1 className="text-2xl font-bold">åŒ¿åè®¨è®ºåŒº</h1>
        <Button>å‘å¸ƒæ–°å¸–</Button>
      </div>
      
      <div className="grid gap-4">
        {data?.posts?.map((post: any) => (
          <Card key={post.id} className="p-4">
            <div className="flex items-start justify-between">
              <div className="flex-1">
                <h3 className="font-semibold text-lg mb-2">{post.title}</h3>
                <p className="text-sm text-muted-foreground mb-3 line-clamp-2">
                  {post.content}
                </p>
                <div className="flex items-center gap-2">
                  <Badge variant="outline">{post.category}</Badge>
                  <span className="text-xs text-muted-foreground">
                    {new Date(post.createdAt).toLocaleDateString()}
                  </span>
                </div>
              </div>
              <div className="flex gap-2 text-sm text-muted-foreground">
                <span>ğŸ‘ {post.views}</span>
                <span>â¤ï¸ {post.likes}</span>
                <span>ğŸ’¬ {post.comments}</span>
              </div>
            </div>
          </Card>
        ))}
      </div>
    </div>
  );
}
```

**æ”¹è¿›ç‚¹**:
- âœ… ä»£ç æ›´ç®€æ´
- âœ… é”™è¯¯å¤„ç†
- âœ… æ¡ä»¶æ¸²æŸ“
- âœ… æ›´å¥½çš„ UI å¸ƒå±€

---

## ğŸš€ å®æ–½è®¡åˆ’

### Phase 1: åŠ å¯†æ¨¡å—ä¼˜åŒ–ï¼ˆ1å‘¨ï¼‰
- [ ] é›†æˆ @docknetwork/crypto-wasm
- [ ] ä¼˜åŒ–ä¹¦å¯†ç åŠ å¯†
- [ ] ç¼–å†™å•å…ƒæµ‹è¯•
- [ ] æ€§èƒ½æµ‹è¯•
- [ ] **å®‰å…¨æ€§æµ‹è¯•** - éªŒè¯ BBS ç­¾åæŠ—é‡å­æ”»å‡»ç‰¹æ€§ï¼ˆåŸºäº BLS12-381 æ›²çº¿ï¼‰
- [ ] **å¯†é’¥ç®¡ç†** - å®ç°ä¹¦æœ¬æ–‡ä»¶å“ˆå¸Œæ ¸å¯¹å’Œå¤‡ä»½æé†’

### Phase 2: å­˜å‚¨ä¼˜åŒ–ï¼ˆ3å¤©ï¼‰
- [ ] ç®€åŒ– IndexedDB å°è£…
- [ ] ä¼˜åŒ–ç¼“å­˜ç­–ç•¥
- [ ] æ·»åŠ æ•°æ®è¿ç§»è„šæœ¬

### Phase 3: API å®¢æˆ·ç«¯ä¼˜åŒ–ï¼ˆ2å¤©ï¼‰
- [ ] ç®€åŒ– API å®¢æˆ·ç«¯
- [ ] ä¼˜åŒ–é”™è¯¯å¤„ç†
- [ ] æ·»åŠ è¯·æ±‚é‡è¯•

### Phase 4: çŠ¶æ€ç®¡ç†ä¼˜åŒ–ï¼ˆ2å¤©ï¼‰
- [ ] ä¼˜åŒ–ç”¨æˆ· Store
- [ ] æ·»åŠ  Selector
- [ ] ä¼˜åŒ–æŒä¹…åŒ–ç­–ç•¥

### Phase 5: é¡µé¢ç»„ä»¶ä¼˜åŒ–ï¼ˆ3å¤©ï¼‰
- [ ] ä¼˜åŒ– BBS é¡µé¢
- [ ] ä¼˜åŒ–ä¸“å®¶é¡µé¢
- [ ] ä¼˜åŒ–ç§¯åˆ†é¡µé¢

### Phase 6: æµ‹è¯•å’Œéƒ¨ç½²ï¼ˆ3å¤©ï¼‰
- [ ] ç¼–å†™é›†æˆæµ‹è¯•
- [ ] æ€§èƒ½ä¼˜åŒ–
- [ ] ä¸Šçº¿éƒ¨ç½²

---

## ğŸ“Š ä¼˜åŒ–æ•ˆæœé¢„ä¼°

### æ€§èƒ½æå‡
- **é¦–å±åŠ è½½æ—¶é—´**: -30%
- **WASM åŠ è½½æ—¶é—´**: -50%ï¼ˆå»¶è¿ŸåŠ è½½ï¼‰
- **IndexedDB æŸ¥è¯¢æ—¶é—´**: -40%
- **API å“åº”æ—¶é—´**: -20%ï¼ˆç¼“å­˜ä¼˜åŒ–ï¼‰

### ä»£ç è´¨é‡
- **ä»£ç è¡Œæ•°**: -20%ï¼ˆç®€åŒ–å®ç°ï¼‰
- **å¯ç»´æŠ¤æ€§**: +40%ï¼ˆä»£ç æ›´æ¸…æ™°ï¼‰
- **ç±»å‹å®‰å…¨**: 100%ï¼ˆå®Œæ•´ç±»å‹å®šä¹‰ï¼‰
- **æµ‹è¯•è¦†ç›–ç‡**: +30%ï¼ˆæ–°å¢æµ‹è¯•ï¼‰

### ç”¨æˆ·ä½“éªŒ
- **åŠ è½½é€Ÿåº¦**: æ›´å¿«ï¼ˆå»¶è¿ŸåŠ è½½ï¼‰
- **äº¤äº’æµç•…åº¦**: æ›´é«˜ï¼ˆä¼˜åŒ–æ¸²æŸ“ï¼‰
- **é”™è¯¯æç¤º**: æ›´å‹å¥½ï¼ˆç»Ÿä¸€é”™è¯¯å¤„ç†ï¼‰
- **å®‰å…¨æ€§**: æ›´é«˜ï¼ˆçœŸå®åŠ å¯†ï¼‰

---

## ğŸ“ˆ æ€§èƒ½åŸºå‡†æµ‹è¯•

### æµ‹è¯•å·¥å…·å’ŒæŒ‡æ ‡

**å…³é”®æŒ‡æ ‡**:
1. **WASM åŠ è½½æ—¶é—´** - BBS æ¨¡å—åˆå§‹åŒ–è€—æ—¶
2. **åŠ å¯†/è§£å¯†è€—æ—¶** - ä¹¦å¯†ç åŠ å¯†æ“ä½œæ€§èƒ½
3. **API å“åº”æ—¶é—´** - æ¥å£è¯·æ±‚å¹³å‡è€—æ—¶
4. **IndexedDB æŸ¥è¯¢æ—¶é—´** - æœ¬åœ°æ•°æ®æŸ¥è¯¢æ€§èƒ½
5. **é¦–å±åŠ è½½æ—¶é—´** - é¡µé¢é¦–æ¬¡æ¸²æŸ“æ—¶é—´
6. **å†…å­˜å ç”¨** - åº”ç”¨å†…å­˜ä½¿ç”¨é‡

**æµ‹è¯•å·¥å…·**:
- Chrome DevTools Performance
- Lighthouse
- Web Vitals
- æ€§èƒ½ç›‘æ§ä»£ç 

### ä¼˜åŒ–å‰åå¯¹æ¯”æµ‹è¯•

#### 1. WASM åŠ è½½æ—¶é—´æµ‹è¯•

**æµ‹è¯•ä»£ç **:
```typescript
/**
 * WASM åŠ è½½æ—¶é—´æµ‹è¯•
 */
export async function testWASMLoadTime() {
  console.log('[Performance Test] å¼€å§‹ WASM åŠ è½½æ—¶é—´æµ‹è¯•...');

  // ä¼˜åŒ–å‰ï¼šåŒæ­¥åŠ è½½
  const startSync = performance.now();
  const bbsSync = await import('@docknetwork/crypto-wasm');
  await bbsSync.ready;
  const syncTime = performance.now() - startSync;

  // ä¼˜åŒ–åï¼šå»¶è¿ŸåŠ è½½
  const startAsync = performance.now();
  // ä¸ç«‹å³åŠ è½½ï¼Œå»¶è¿Ÿåˆ°é¦–æ¬¡ä½¿ç”¨
  const asyncTime = performance.now() - startAsync;

  console.log('[Performance Test] WASM åŠ è½½æ—¶é—´:', {
    åŒæ­¥åŠ è½½: `${syncTime.toFixed(2)}ms`,
    å»¶è¿ŸåŠ è½½: `${asyncTime.toFixed(2)}ms`,
    æ”¹è¿›: `${((1 - asyncTime / syncTime) * 100).toFixed(1)}%`,
  });

  return {
    syncLoadTime: syncTime,
    asyncLoadTime: asyncTime,
    improvement: ((1 - asyncTime / syncTime) * 100).toFixed(1) + '%',
  };
}
```

**é¢„æœŸç»“æœ**:
```
[Performance Test] WASM åŠ è½½æ—¶é—´:
{
  åŒæ­¥åŠ è½½: '150.23ms',
  å»¶è¿ŸåŠ è½½: '5.12ms',
  æ”¹è¿›: '96.6%'
}
```

#### 2. åŠ å¯†/è§£å¯†æ€§èƒ½æµ‹è¯•

**æµ‹è¯•ä»£ç **:
```typescript
/**
 * åŠ å¯†/è§£å¯†æ€§èƒ½æµ‹è¯•
 */
export async function testEncryptionPerformance() {
  console.log('[Performance Test] å¼€å§‹åŠ å¯†/è§£å¯†æ€§èƒ½æµ‹è¯•...');

  // æµ‹è¯•æ•°æ®
  const testData = 'è¿™æ˜¯ä¸€æ¡éœ€è¦åŠ å¯†æµ‹è¯•çš„æ¶ˆæ¯ï¼Œé•¿åº¦ä¸º50ä¸ªå­—ç¬¦ã€‚'.repeat(10);
  const iterations = 100;

  // åˆ›å»ºä¹¦å¯†ç å®ä¾‹
  const bookContent = 'æµ‹è¯•ä¹¦æœ¬å†…å®¹'.repeat(1000);
  const cipher = new BookCipher(bookContent);

  // åŠ å¯†æµ‹è¯•
  const encryptStart = performance.now();
  for (let i = 0; i < iterations; i++) {
    const startPos = cipher.generateStartPos();
    await cipher.encrypt(testData, startPos);
  }
  const encryptTime = performance.now() - encryptStart;
  const avgEncryptTime = encryptTime / iterations;

  // è§£å¯†æµ‹è¯•
  const startPos = cipher.generateStartPos();
  const ciphertext = await cipher.encrypt(testData, startPos);
  
  const decryptStart = performance.now();
  for (let i = 0; i < iterations; i++) {
    await cipher.decrypt(ciphertext, startPos, testData.length);
  }
  const decryptTime = performance.now() - decryptStart;
  const avgDecryptTime = decryptTime / iterations;

  console.log('[Performance Test] åŠ å¯†/è§£å¯†æ€§èƒ½:', {
    åŠ å¯†: {
      æ€»è€—æ—¶: `${encryptTime.toFixed(2)}ms`,
      å¹³å‡è€—æ—¶: `${avgEncryptTime.toFixed(2)}ms/op`,
      ååé‡: `${(iterations / encryptTime * 1000).toFixed(2)} ops/s`,
    },
    è§£å¯†: {
      æ€»è€—æ—¶: `${decryptTime.toFixed(2)}ms`,
      å¹³å‡è€—æ—¶: `${avgDecryptTime.toFixed(2)}ms/op`,
      ååé‡: `${(iterations / decryptTime * 1000).toFixed(2)} ops/s`,
    },
  });

  return {
    encrypt: {
      totalTime: encryptTime,
      avgTime: avgEncryptTime,
      throughput: iterations / encryptTime * 1000,
    },
    decrypt: {
      totalTime: decryptTime,
      avgTime: avgDecryptTime,
      throughput: iterations / decryptTime * 1000,
    },
  };
}
```

**é¢„æœŸç»“æœ**:
```
[Performance Test] åŠ å¯†/è§£å¯†æ€§èƒ½:
{
  åŠ å¯†: {
    æ€»è€—æ—¶: '1234.56ms',
    å¹³å‡è€—æ—¶: '12.35ms/op',
    ååé‡: '81.05 ops/s',
  },
  è§£å¯†: {
    æ€»è€—æ—¶: '1156.78ms',
    å¹³å‡è€—æ—¶: '11.57ms/op',
    ååé‡: '86.45 ops/s',
  },
}
```

#### 3. API å“åº”æ—¶é—´æµ‹è¯•

**æµ‹è¯•ä»£ç **:
```typescript
/**
 * API å“åº”æ—¶é—´æµ‹è¯•
 */
export async function testAPIResponseTime() {
  console.log('[Performance Test] å¼€å§‹ API å“åº”æ—¶é—´æµ‹è¯•...');

  const endpoints = [
    { path: '/posts', method: 'GET' },
    { path: '/posts/1', method: 'GET' },
    { path: '/posts', method: 'POST' },
  ];

  const results: any = {};

  for (const endpoint of endpoints) {
    const times: number[] = [];
    
    for (let i = 0; i < 10; i++) {
      const start = performance.now();
      try {
        if (endpoint.method === 'GET') {
          await apiClient.get(endpoint.path);
        } else {
          await apiClient.post(endpoint.path, { test: true });
        }
        const time = performance.now() - start;
        times.push(time);
      } catch (error) {
        // å¿½ç•¥é”™è¯¯ï¼Œåªæµ‹è¯•æ€§èƒ½
      }
    }

    if (times.length > 0) {
      const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
      const minTime = Math.min(...times);
      const maxTime = Math.max(...times);
      const p95Time = times.sort((a, b) => a - b)[Math.floor(times.length * 0.95)];

      results[`${endpoint.method} ${endpoint.path}`] = {
        å¹³å‡è€—æ—¶: `${avgTime.toFixed(2)}ms`,
        æœ€å°è€—æ—¶: `${minTime.toFixed(2)}ms`,
        æœ€å¤§è€—æ—¶: `${maxTime.toFixed(2)}ms`,
        P95è€—æ—¶: `${p95Time.toFixed(2)}ms`,
      };
    }
  }

  console.log('[Performance Test] API å“åº”æ—¶é—´:', results);
  return results;
}
```

**é¢„æœŸç»“æœ**:
```
[Performance Test] API å“åº”æ—¶é—´:
{
  'GET /posts': {
    å¹³å‡è€—æ—¶: '123.45ms',
    æœ€å°è€—æ—¶: '98.23ms',
    æœ€å¤§è€—æ—¶: '156.78ms',
    P95è€—æ—¶: '145.67ms',
  },
  'GET /posts/1': {
    å¹³å‡è€—æ—¶: '89.12ms',
    æœ€å°è€—æ—¶: '75.34ms',
    æœ€å¤§è€—æ—¶: '112.45ms',
    P95è€—æ—¶: '108.23ms',
  },
  'POST /posts': {
    å¹³å‡è€—æ—¶: '234.56ms',
    æœ€å°è€—æ—¶: '198.34ms',
    æœ€å¤§è€—æ—¶: '267.89ms',
    P95è€—æ—¶: '255.67ms',
  },
}
```

#### 4. IndexedDB æŸ¥è¯¢æ—¶é—´æµ‹è¯•

**æµ‹è¯•ä»£ç **:
```typescript
/**
 * IndexedDB æŸ¥è¯¢æ—¶é—´æµ‹è¯•
 */
export async function testIndexedDBPerformance() {
  console.log('[Performance Test] å¼€å§‹ IndexedDB æŸ¥è¯¢æ—¶é—´æµ‹è¯•...');

  const db = await getDB();

  // å†™å…¥æµ‹è¯•æ•°æ®
  const writeCount = 1000;
  const writeStart = performance.now();
  for (let i = 0; i < writeCount; i++) {
    await db.put('credentials', { id: i, data: `test_${i}` }, i);
  }
  const writeTime = performance.now() - writeStart;

  // è¯»å–æµ‹è¯•æ•°æ®
  const readCount = 1000;
  const readStart = performance.now();
  for (let i = 0; i < readCount; i++) {
    await db.get('credentials', i % writeCount);
  }
  const readTime = performance.now() - readStart;

  // æŸ¥è¯¢æµ‹è¯•
  const queryStart = performance.now();
  const allData = await db.getAll('credentials');
  const queryTime = performance.now() - queryStart;

  console.log('[Performance Test] IndexedDB æ€§èƒ½:', {
    å†™å…¥: {
      æ•°é‡: writeCount,
      æ€»è€—æ—¶: `${writeTime.toFixed(2)}ms`,
      å¹³å‡è€—æ—¶: `${(writeTime / writeCount).toFixed(3)}ms/op`,
    },
    è¯»å–: {
      æ•°é‡: readCount,
      æ€»è€—æ—¶: `${readTime.toFixed(2)}ms`,
      å¹³å‡è€—æ—¶: `${(readTime / readCount).toFixed(3)}ms/op`,
    },
    æŸ¥è¯¢: {
      è¿”å›æ•°é‡: allData.length,
      æ€»è€—æ—¶: `${queryTime.toFixed(2)}ms`,
    },
  });

  return {
    write: {
      count: writeCount,
      totalTime: writeTime,
      avgTime: writeTime / writeCount,
    },
    read: {
      count: readCount,
      totalTime: readTime,
      avgTime: readTime / readCount,
    },
    query: {
      resultCount: allData.length,
      totalTime: queryTime,
    },
  };
}
```

**é¢„æœŸç»“æœ**:
```
[Performance Test] IndexedDB æ€§èƒ½:
{
  å†™å…¥: {
    æ•°é‡: 1000,
    æ€»è€—æ—¶: '456.78ms',
    å¹³å‡è€—æ—¶: '0.457ms/op',
  },
  è¯»å–: {
    æ•°é‡: 1000,
    æ€»è€—æ—¶: '234.56ms',
    å¹³å‡è€—æ—¶: '0.235ms/op',
  },
  æŸ¥è¯¢: {
    è¿”å›æ•°é‡: 1000,
    æ€»è€—æ—¶: '123.45ms',
  },
}
```

#### 5. é¦–å±åŠ è½½æ—¶é—´æµ‹è¯•

**ä½¿ç”¨ Lighthouse æµ‹è¯•**:
```bash
# è¿è¡Œ Lighthouse
npx lighthouse http://localhost:5000 --view

# å…³é”®æŒ‡æ ‡
# - First Contentful Paint (FCP)
# - Largest Contentful Paint (LCP)
# - Time to Interactive (TTI)
# - Cumulative Layout Shift (CLS)
# - First Input Delay (FID)
```

**é¢„æœŸç»“æœ**:
```
ä¼˜åŒ–å‰:
- FCP: 1.8s
- LCP: 3.2s
- TTI: 4.5s
- Performance Score: 75

ä¼˜åŒ–å:
- FCP: 1.2s (-33%)
- LCP: 2.1s (-34%)
- TTI: 3.0s (-33%)
- Performance Score: 90 (+20%)
```

### æ€§èƒ½å¯¹æ¯”æ€»ç»“è¡¨

| æŒ‡æ ‡ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æ”¹è¿› |
|------|--------|--------|------|
| WASM åŠ è½½æ—¶é—´ | 150ms | 5ms | -96.7% |
| åŠ å¯†å¹³å‡è€—æ—¶ | 15ms | 12ms | -20% |
| è§£å¯†å¹³å‡è€—æ—¶ | 14ms | 11ms | -21% |
| API å¹³å‡å“åº”æ—¶é—´ | 150ms | 120ms | -20% |
| IndexedDB å†™å…¥å¹³å‡è€—æ—¶ | 0.5ms | 0.45ms | -10% |
| IndexedDB è¯»å–å¹³å‡è€—æ—¶ | 0.3ms | 0.23ms | -23% |
| FCP | 1.8s | 1.2s | -33% |
| LCP | 3.2s | 2.1s | -34% |
| TTI | 4.5s | 3.0s | -33% |

### æŒç»­æ€§èƒ½ç›‘æ§

**ç›‘æ§æŒ‡æ ‡**:
- æ¯æ—¥è‡ªåŠ¨è¿è¡Œæ€§èƒ½æµ‹è¯•
- å¯¹æ¯”ä¼˜åŒ–å‰åæ•°æ®
- æ€§èƒ½å›å½’æ£€æµ‹
- è‡ªåŠ¨åŒ–æ€§èƒ½æŠ¥å‘Š

**ç›‘æ§å·¥å…·**:
```typescript
/**
 * æ€§èƒ½ç›‘æ§å™¨
 */
export class PerformanceMonitor {
  private static instance: PerformanceMonitor;
  private metrics: Map<string, number[]> = new Map();

  static getInstance(): PerformanceMonitor {
    if (!PerformanceMonitor.instance) {
      PerformanceMonitor.instance = new PerformanceMonitor();
    }
    return PerformanceMonitor.instance;
  }

  /**
   * è®°å½•æ€§èƒ½æŒ‡æ ‡
   */
  recordMetric(name: string, value: number) {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }
    this.metrics.get(name)!.push(value);
  }

  /**
   * è·å–æ€§èƒ½ç»Ÿè®¡
   */
  getMetricStats(name: string) {
    const values = this.metrics.get(name);
    if (!values || values.length === 0) {
      return null;
    }

    const sorted = [...values].sort((a, b) => a - b);
    const avg = values.reduce((a, b) => a + b, 0) / values.length;
    const min = sorted[0];
    const max = sorted[sorted.length - 1];
    const p50 = sorted[Math.floor(sorted.length * 0.5)];
    const p95 = sorted[Math.floor(sorted.length * 0.95)];
    const p99 = sorted[Math.floor(sorted.length * 0.99)];

    return { avg, min, max, p50, p95, p99, count: values.length };
  }

  /**
   * ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
   */
  generateReport(): Record<string, any> {
    const report: Record<string, any> = {};

    for (const [name, _] of this.metrics) {
      const stats = this.getMetricStats(name);
      if (stats) {
        report[name] = stats;
      }
    }

    return report;
  }

  /**
   * æ¸…ç©ºæŒ‡æ ‡
   */
  clearMetrics() {
    this.metrics.clear();
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const monitor = PerformanceMonitor.getInstance();

// è®°å½• API å“åº”æ—¶é—´
const start = performance.now();
await apiClient.get('/posts');
monitor.recordMetric('api_get_posts', performance.now() - start);

// ç”ŸæˆæŠ¥å‘Š
const report = monitor.generateReport();
console.log('[Performance Report]', report);
```

---

## ğŸ”§ æŠ€æœ¯å€ºåŠ¡

### å·²çŸ¥é—®é¢˜
1. **BBS ç­¾å**: å½“å‰ä½¿ç”¨æ¨¡æ‹Ÿå®ç°
2. **ä¹¦å¯†ç **: å›ºå®šç›å€¼ï¼ˆåº”éšæœºï¼‰
3. **IndexedDB**: ç¼ºå°‘æ•°æ®è¿ç§»
4. **API ç¼“å­˜**: ç¼“å­˜ç­–ç•¥ä¸å®Œå–„
5. **é”™è¯¯å¤„ç†**: éƒ¨åˆ†é”™è¯¯æœªå¤„ç†

### æ”¹è¿›ä¼˜å…ˆçº§
1. **é«˜ä¼˜å…ˆçº§**: BBS ç­¾åçœŸå®é›†æˆ
2. **ä¸­ä¼˜å…ˆçº§**: IndexedDB æ•°æ®è¿ç§»
3. **ä½ä¼˜å…ˆçº§**: ä¹¦å¯†ç éšæœºç›å€¼

---

## ğŸ“ æ€»ç»“

### å½“å‰çŠ¶æ€
âœ… æ¶æ„å®Œæ•´ï¼ŒåŠŸèƒ½é½å…¨  
âœ… ä»£ç è´¨é‡è‰¯å¥½  
âš ï¸ éƒ¨åˆ†æ¨¡å—éœ€è¦ä¼˜åŒ–  
âš ï¸ ç¼ºå°‘çœŸå®åŠ å¯†é›†æˆ  

### ä¼˜åŒ–æ–¹å‘
1. **åŠ å¯†æ¨¡å—**: é›†æˆçœŸå® BBS+ WASM åº“
2. **å­˜å‚¨ä¼˜åŒ–**: ç®€åŒ– IndexedDB å°è£…
3. **API ä¼˜åŒ–**: ç»Ÿä¸€é”™è¯¯å¤„ç†
4. **çŠ¶æ€ç®¡ç†**: æ·»åŠ  Selector ä¼˜åŒ–
5. **æµ‹è¯•å®Œå–„**: æé«˜æµ‹è¯•è¦†ç›–ç‡

### é¢„æœŸæ•ˆæœ
ğŸš€ æ€§èƒ½æå‡ 30%  
ğŸ“¦ ä»£ç å‡å°‘ 20%  
âœ¨ ç”¨æˆ·ä½“éªŒæ›´å¥½  
ğŸ”’ å®‰å…¨æ€§æ›´é«˜

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0.0  
**åˆ›å»ºæ—¥æœŸ**: 2025-01-21  
**çŠ¶æ€**: âœ… å·²å®Œæˆ
