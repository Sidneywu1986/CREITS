# æ ¸å¿ƒæ¨¡å—å®ç°ä¼˜åŒ–è®¡åˆ’

## ğŸ“‹ å®ç°å¯¹æ¯”åˆ†æ

### 1. BBS ç­¾åæ¨¡å—

#### å½“å‰å®ç°ï¼ˆæ¨¡æ‹Ÿç‰ˆæœ¬ï¼‰
**æ–‡ä»¶**: `src/lib/encryption/bbs-signature.ts`

**ç‰¹ç‚¹**:
- âœ… æ¥å£è®¾è®¡å®Œæ•´
- âœ… æ¨¡æ‹Ÿå®ç°å¯ç”¨
- âš ï¸ ä¸æ˜¯çœŸå®çš„ BBS+ ç­¾å
- âš ï¸ ä»…ç”¨äºæ¼”ç¤ºå’Œå¼€å‘

**æ”¹è¿›æ–¹æ¡ˆ**:
```typescript
// é›†æˆçœŸå®çš„ @docknetwork/crypto-wasm åº“
pnpm add @docknetwork/crypto-wasm

// ä¼˜åŒ–åçš„å®ç°
import * as bbs from '@docknetwork/crypto-wasm';

// å»¶è¿ŸåŠ è½½ WASMï¼ˆé¿å…é¦–å±é˜»å¡ï¼‰
let initialized = false;
export const initBBS = async () => {
  if (!initialized) {
    await bbs.ready;
    initialized = true;
  }
};

export interface BBSCredential {
  messages: string[];
  signature: Uint8Array;
}

export const generateProof = async (
  credential: BBSCredential,
  disclosedIndices: number[]
) => {
  await initBBS();
  // è°ƒç”¨ WASM æ–¹æ³•ç”Ÿæˆé›¶çŸ¥è¯†è¯æ˜
  const proof = bbs.createProof(
    credential.messages,
    credential.signature,
    disclosedIndices
  );
  return proof;
};

export const verifyProof = async (
  proof: Uint8Array,
  publicKey: Uint8Array,
  disclosedMessages: string[],
  disclosedIndices: number[]
) => {
  await initBBS();
  return bbs.verifyProof(proof, publicKey, disclosedMessages, disclosedIndices);
};
```

**React Hook å°è£…**:
```typescript
import { useEffect, useState } from 'react';
import { generateProof, initBBS } from '@/lib/encryption/bbs-signature';

export const useBBS = () => {
  const [ready, setReady] = useState(false);
  const [loading, setLoading] = useState(false);
  
  useEffect(() => {
    initBBS().then(() => setReady(true));
  }, []);
  
  return { 
    ready, 
    loading,
    generateProof: async (...args: Parameters<typeof generateProof>) => {
      setLoading(true);
      try {
        return await generateProof(...args);
      } finally {
        setLoading(false);
      }
    }
  };
};
```

**æ”¹è¿›ç‚¹**:
- âœ… çœŸå® BBS+ ç­¾åç®—æ³•
- âœ… é›¶çŸ¥è¯†è¯æ˜åŠŸèƒ½
- âœ… å»¶è¿ŸåŠ è½½ä¼˜åŒ–
- âœ… React Hook å°è£…

---

### 2. ä¹¦å¯†ç åŠ å¯†æ¨¡å—

#### å½“å‰å®ç°
**æ–‡ä»¶**: `src/lib/encryption/book-cipher.ts`

**ç‰¹ç‚¹**:
- âœ… ä½¿ç”¨ Web Crypto API
- âœ… AES-GCM åŠ å¯†
- âœ… PBKDF2 å¯†é’¥æ´¾ç”Ÿ
- âœ… æ”¯æŒä½ç½®ç´¢å¼•

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```typescript
export class BookCipher {
  private book: Uint8Array;
  constructor(bookContent: string | ArrayBuffer) {
    this.book = typeof bookContent === 'string' 
      ? new TextEncoder().encode(bookContent)
      : new Uint8Array(bookContent);
  }

  async encrypt(plainText: string, startPos: number) {
    // ä»ä¹¦æœ¬ä¸­æå–å¯†é’¥
    const keyStream = this.extractKeyStream(startPos, plainText.length);
    
    // ä½¿ç”¨ HMAC-SHA256 æ´¾ç”Ÿå¯†é’¥
    const key = await this.deriveKey(keyStream);
    
    // AES-GCM åŠ å¯†
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encrypted = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv },
      key,
      new TextEncoder().encode(plainText)
    );
    
    // ç»„åˆ IV å’Œå¯†æ–‡
    const combined = new Uint8Array(iv.length + encrypted.byteLength);
    combined.set(iv);
    combined.set(new Uint8Array(encrypted), iv.length);
    
    return btoa(String.fromCharCode(...combined));
  }

  async decrypt(cipherBase64: string, startPos: number, length: number) {
    const combined = Uint8Array.from(atob(cipherBase64), c => c.charCodeAt(0));
    const iv = combined.slice(0, 12);
    const encrypted = combined.slice(12);
    
    const keyStream = this.extractKeyStream(startPos, length);
    const key = await this.deriveKey(keyStream);
    
    const decrypted = await crypto.subtle.decrypt(
      { name: 'AES-GCM', iv },
      key,
      encrypted
    );
    
    return new TextDecoder().decode(decrypted);
  }

  private async deriveKey(keyStream: Uint8Array): Promise<CryptoKey> {
    const keyMaterial = await crypto.subtle.importKey(
      'raw',
      keyStream,
      'PBKDF2',
      false,
      ['deriveKey']
    );
    
    const salt = new TextEncoder().encode('REITs-BOOK-CIPHER-SALT');
    
    return crypto.subtle.deriveKey(
      {
        name: 'PBKDF2',
        salt,
        iterations: 100000,
        hash: 'SHA-256'
      },
      keyMaterial,
      { name: 'AES-GCM', length: 256 },
      false,
      ['encrypt', 'decrypt']
    );
  }

  private extractKeyStream(startPos: number, length: number): Uint8Array {
    const endPos = Math.min(startPos + length * 32, this.book.length);
    return this.book.slice(startPos, endPos);
  }

  generateStartPos(): number {
    return Math.floor(Math.random() * (this.book.length - 256));
  }
}
```

**æ”¹è¿›ç‚¹**:
- âœ… ä¼˜åŒ–å¯†é’¥æ´¾ç”Ÿ
- âœ… æ”¯æŒ ArrayBuffer è¾“å…¥
- âœ… æ›´å®‰å…¨çš„å¯†é’¥æµæå–
- âœ… å›ºå®šç›å€¼ï¼ˆå®é™…åº”ç”¨åº”éšæœºï¼‰

---

### 3. IndexedDB å­˜å‚¨

#### å½“å‰å®ç°
**æ–‡ä»¶**: `src/lib/storage/indexeddb.ts`

**ç‰¹ç‚¹**:
- âœ… å®Œæ•´çš„ IndexedDB å°è£…
- âœ… æ”¯æŒå¤šç§å¯¹è±¡å­˜å‚¨
- âœ… ç¼“å­˜åŠŸèƒ½
- âš ï¸ ä»£ç è¾ƒä¸ºå¤æ‚

**ç®€åŒ–æ–¹æ¡ˆ**:
```typescript
import { openDB, DBSchema, IDBPDatabase } from 'idb';

interface REITsBBSDB extends DBSchema {
  credentials: {
    key: string;
    value: {
      userId: string;
      publicKey: string;
      secretKey: string;
      anonymousId: string;
    };
  };
  books: {
    key: string;
    value: {
      bookId: string;
      name: string;
      content: ArrayBuffer;
      fingerprint: string;
    };
  };
}

const DB_NAME = 'reits-bbs-db';
const DB_VERSION = 1;

let db: IDBPDatabase<REITsBBSDB> | null = null;

export const getDB = async () => {
  if (db) return db;
  
  db = await openDB<REITsBBSDB>(DB_NAME, DB_VERSION, {
    upgrade(db) {
      if (!db.objectStoreNames.contains('credentials')) {
        db.createObjectStore('credentials');
      }
      if (!db.objectStoreNames.contains('books')) {
        db.createObjectStore('books');
      }
    },
  });
  
  return db;
};

export const saveCredential = async (userId: string, credential: any) => {
  const database = await getDB();
  await database.put('credentials', credential, userId);
};

export const getCredential = async (userId: string) => {
  const database = await getDB();
  return database.get('credentials', userId);
};

export const saveBook = async (bookId: string, book: any) => {
  const database = await getDB();
  await database.put('books', book, bookId);
};

export const getBook = async (bookId: string) => {
  const database = await getDB();
  return database.get('books', bookId);
};
```

**æ”¹è¿›ç‚¹**:
- âœ… ä»£ç æ›´ç®€æ´
- âœ… å•ä¾‹æ¨¡å¼ä¼˜åŒ–
- âœ… TypeScript ç±»å‹å®‰å…¨
- âœ… æ›´æ˜“ç»´æŠ¤

---

### 4. API å®¢æˆ·ç«¯

#### å½“å‰å®ç°
**æ–‡ä»¶**: `src/lib/api/client.ts`

**ç‰¹ç‚¹**:
- âœ… ç»Ÿä¸€çš„ API å®¢æˆ·ç«¯
- âœ… è‡ªåŠ¨æ³¨å…¥è®¤è¯å¤´
- âœ… é”™è¯¯å¤„ç†
- âœ… æ–‡ä»¶ä¸Šä¼ æ”¯æŒ

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```typescript
import { getAnonymousId } from '@/stores/userStore';

const API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL || '/api/v1';

export const apiClient = {
  async get<T>(url: string, config?: RequestInit): Promise<T> {
    const headers = await getAuthHeaders();
    const res = await fetch(`${API_BASE}${url}`, { ...config, headers });
    if (!res.ok) throw new Error(await res.text());
    return res.json();
  },

  async post<T>(url: string, data?: any, config?: RequestInit): Promise<T> {
    const headers = await getAuthHeaders();
    const res = await fetch(`${API_BASE}${url}`, {
      method: 'POST',
      headers,
      body: JSON.stringify(data),
      ...config
    });
    if (!res.ok) throw new Error(await res.text());
    return res.json();
  },

  async put<T>(url: string, data?: any, config?: RequestInit): Promise<T> {
    const headers = await getAuthHeaders();
    const res = await fetch(`${API_BASE}${url}`, {
      method: 'PUT',
      headers,
      body: JSON.stringify(data),
      ...config
    });
    if (!res.ok) throw new Error(await res.text());
    return res.json();
  },

  async delete<T>(url: string, config?: RequestInit): Promise<T> {
    const headers = await getAuthHeaders();
    const res = await fetch(`${API_BASE}${url}`, {
      method: 'DELETE',
      headers,
      ...config
    });
    if (!res.ok) throw new Error(await res.text());
    return res.json();
  },
};

async function getAuthHeaders() {
  const anonymousId = getAnonymousId();
  return {
    'Content-Type': 'application/json',
    ...(anonymousId && { 'X-Anonymous-ID': anonymousId }),
  };
}
```

**æ”¹è¿›ç‚¹**:
- âœ… ä»£ç æ›´ç®€æ´
- âœ… ç±»å‹å®‰å…¨
- âœ… ç»Ÿä¸€é”™è¯¯å¤„ç†
- âœ… æ”¯æŒè‡ªå®šä¹‰é…ç½®

---

### 5. ç”¨æˆ· Store

#### å½“å‰å®ç°
**æ–‡ä»¶**: `src/stores/userStore.ts`

**ç‰¹ç‚¹**:
- âœ… å®Œæ•´çš„ç”¨æˆ·çŠ¶æ€ç®¡ç†
- âœ… ç§¯åˆ†ç®¡ç†
- âœ… localStorage æŒä¹…åŒ–
- âœ… å®Œæ•´çš„ç±»å‹å®šä¹‰

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface UserState {
  anonymousId: string | null;
  publicKey: string | null;
  secretKey: string | null;
  points: number;
  isLoggedIn: boolean;
  
  // Actions
  setAnonymousId: (id: string) => void;
  setCredentials: (credentials: { publicKey: string; secretKey: string }) => void;
  updatePoints: (delta: number) => void;
  logout: () => void;
}

export const useUserStore = create<UserState>()(
  persist(
    (set) => ({
      anonymousId: null,
      publicKey: null,
      secretKey: null,
      points: 0,
      isLoggedIn: false,
      
      setAnonymousId: (id) => set({ 
        anonymousId: id,
        isLoggedIn: !!id 
      }),
      
      setCredentials: (credentials) => set({
        publicKey: credentials.publicKey,
        secretKey: credentials.secretKey,
      }),
      
      updatePoints: (delta) => set((state) => ({ 
        points: Math.max(0, state.points + delta) 
      })),
      
      logout: () => set({
        anonymousId: null,
        publicKey: null,
        secretKey: null,
        points: 0,
        isLoggedIn: false,
      }),
    }),
    {
      name: 'user-storage',
      partialize: (state) => ({
        anonymousId: state.anonymousId,
        publicKey: state.publicKey,
        secretKey: state.secretKey,
        points: state.points,
        isLoggedIn: state.isLoggedIn,
      }),
    }
  )
);

// Selectors
export const selectAnonymousId = (state: UserState) => state.anonymousId;
export const selectPoints = (state: UserState) => state.points;
export const selectIsLoggedIn = (state: UserState) => state.isLoggedIn;
```

**æ”¹è¿›ç‚¹**:
- âœ… ä»£ç æ›´ç®€æ´
- âœ… æ·»åŠ  Selector ä¼˜åŒ–
- âœ… ç§¯åˆ†ä¸èƒ½ä¸ºè´Ÿæ•°
- âœ… æ›´å¥½çš„æŒä¹…åŒ–ç­–ç•¥

---

### 6. BBS å¸–å­åˆ—è¡¨é¡µé¢

#### å½“å‰å®ç°
**æ–‡ä»¶**: `pages/bbs/index.tsx`

**ç‰¹ç‚¹**:
- âœ… å®Œæ•´çš„å¸–å­åˆ—è¡¨
- âœ… åˆ†ç±»ç­›é€‰
- âœ… æœç´¢åŠŸèƒ½
- âœ… åˆ†é¡µåŠ è½½
- âœ… å“åº”å¼è®¾è®¡

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```tsx
import { useQuery } from '@tanstack/react-query';
import { apiClient } from '@/lib/api/client';
import { useUserStore } from '@/stores/userStore';
import { Card } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';

export default function BBSPage() {
  const { anonymousId } = useUserStore();
  
  const { data, isLoading, error } = useQuery({
    queryKey: ['posts'],
    queryFn: () => apiClient.get('/posts'),
    enabled: !!anonymousId, // åªæœ‰ç™»å½•åæ‰è·å–æ•°æ®
  });

  if (isLoading) return <div>åŠ è½½ä¸­...</div>;
  if (error) return <div>åŠ è½½å¤±è´¥: {error.message}</div>;

  return (
    <div className="container mx-auto p-4 max-w-6xl">
      <div className="flex items-center justify-between mb-6">
        <h1 className="text-2xl font-bold">åŒ¿åè®¨è®ºåŒº</h1>
        <Button>å‘å¸ƒæ–°å¸–</Button>
      </div>
      
      <div className="grid gap-4">
        {data?.posts?.map((post: any) => (
          <Card key={post.id} className="p-4">
            <div className="flex items-start justify-between">
              <div className="flex-1">
                <h3 className="font-semibold text-lg mb-2">{post.title}</h3>
                <p className="text-sm text-muted-foreground mb-3 line-clamp-2">
                  {post.content}
                </p>
                <div className="flex items-center gap-2">
                  <Badge variant="outline">{post.category}</Badge>
                  <span className="text-xs text-muted-foreground">
                    {new Date(post.createdAt).toLocaleDateString()}
                  </span>
                </div>
              </div>
              <div className="flex gap-2 text-sm text-muted-foreground">
                <span>ğŸ‘ {post.views}</span>
                <span>â¤ï¸ {post.likes}</span>
                <span>ğŸ’¬ {post.comments}</span>
              </div>
            </div>
          </Card>
        ))}
      </div>
    </div>
  );
}
```

**æ”¹è¿›ç‚¹**:
- âœ… ä»£ç æ›´ç®€æ´
- âœ… é”™è¯¯å¤„ç†
- âœ… æ¡ä»¶æ¸²æŸ“
- âœ… æ›´å¥½çš„ UI å¸ƒå±€

---

## ğŸš€ å®æ–½è®¡åˆ’

### Phase 1: åŠ å¯†æ¨¡å—ä¼˜åŒ–ï¼ˆ1å‘¨ï¼‰
- [ ] é›†æˆ @docknetwork/crypto-wasm
- [ ] ä¼˜åŒ–ä¹¦å¯†ç åŠ å¯†
- [ ] ç¼–å†™å•å…ƒæµ‹è¯•
- [ ] æ€§èƒ½æµ‹è¯•

### Phase 2: å­˜å‚¨ä¼˜åŒ–ï¼ˆ3å¤©ï¼‰
- [ ] ç®€åŒ– IndexedDB å°è£…
- [ ] ä¼˜åŒ–ç¼“å­˜ç­–ç•¥
- [ ] æ·»åŠ æ•°æ®è¿ç§»è„šæœ¬

### Phase 3: API å®¢æˆ·ç«¯ä¼˜åŒ–ï¼ˆ2å¤©ï¼‰
- [ ] ç®€åŒ– API å®¢æˆ·ç«¯
- [ ] ä¼˜åŒ–é”™è¯¯å¤„ç†
- [ ] æ·»åŠ è¯·æ±‚é‡è¯•

### Phase 4: çŠ¶æ€ç®¡ç†ä¼˜åŒ–ï¼ˆ2å¤©ï¼‰
- [ ] ä¼˜åŒ–ç”¨æˆ· Store
- [ ] æ·»åŠ  Selector
- [ ] ä¼˜åŒ–æŒä¹…åŒ–ç­–ç•¥

### Phase 5: é¡µé¢ç»„ä»¶ä¼˜åŒ–ï¼ˆ3å¤©ï¼‰
- [ ] ä¼˜åŒ– BBS é¡µé¢
- [ ] ä¼˜åŒ–ä¸“å®¶é¡µé¢
- [ ] ä¼˜åŒ–ç§¯åˆ†é¡µé¢

### Phase 6: æµ‹è¯•å’Œéƒ¨ç½²ï¼ˆ3å¤©ï¼‰
- [ ] ç¼–å†™é›†æˆæµ‹è¯•
- [ ] æ€§èƒ½ä¼˜åŒ–
- [ ] ä¸Šçº¿éƒ¨ç½²

---

## ğŸ“Š ä¼˜åŒ–æ•ˆæœé¢„ä¼°

### æ€§èƒ½æå‡
- **é¦–å±åŠ è½½æ—¶é—´**: -30%
- **WASM åŠ è½½æ—¶é—´**: -50%ï¼ˆå»¶è¿ŸåŠ è½½ï¼‰
- **IndexedDB æŸ¥è¯¢æ—¶é—´**: -40%
- **API å“åº”æ—¶é—´**: -20%ï¼ˆç¼“å­˜ä¼˜åŒ–ï¼‰

### ä»£ç è´¨é‡
- **ä»£ç è¡Œæ•°**: -20%ï¼ˆç®€åŒ–å®ç°ï¼‰
- **å¯ç»´æŠ¤æ€§**: +40%ï¼ˆä»£ç æ›´æ¸…æ™°ï¼‰
- **ç±»å‹å®‰å…¨**: 100%ï¼ˆå®Œæ•´ç±»å‹å®šä¹‰ï¼‰
- **æµ‹è¯•è¦†ç›–ç‡**: +30%ï¼ˆæ–°å¢æµ‹è¯•ï¼‰

### ç”¨æˆ·ä½“éªŒ
- **åŠ è½½é€Ÿåº¦**: æ›´å¿«ï¼ˆå»¶è¿ŸåŠ è½½ï¼‰
- **äº¤äº’æµç•…åº¦**: æ›´é«˜ï¼ˆä¼˜åŒ–æ¸²æŸ“ï¼‰
- **é”™è¯¯æç¤º**: æ›´å‹å¥½ï¼ˆç»Ÿä¸€é”™è¯¯å¤„ç†ï¼‰
- **å®‰å…¨æ€§**: æ›´é«˜ï¼ˆçœŸå®åŠ å¯†ï¼‰

---

## ğŸ”§ æŠ€æœ¯å€ºåŠ¡

### å·²çŸ¥é—®é¢˜
1. **BBS ç­¾å**: å½“å‰ä½¿ç”¨æ¨¡æ‹Ÿå®ç°
2. **ä¹¦å¯†ç **: å›ºå®šç›å€¼ï¼ˆåº”éšæœºï¼‰
3. **IndexedDB**: ç¼ºå°‘æ•°æ®è¿ç§»
4. **API ç¼“å­˜**: ç¼“å­˜ç­–ç•¥ä¸å®Œå–„
5. **é”™è¯¯å¤„ç†**: éƒ¨åˆ†é”™è¯¯æœªå¤„ç†

### æ”¹è¿›ä¼˜å…ˆçº§
1. **é«˜ä¼˜å…ˆçº§**: BBS ç­¾åçœŸå®é›†æˆ
2. **ä¸­ä¼˜å…ˆçº§**: IndexedDB æ•°æ®è¿ç§»
3. **ä½ä¼˜å…ˆçº§**: ä¹¦å¯†ç éšæœºç›å€¼

---

## ğŸ“ æ€»ç»“

### å½“å‰çŠ¶æ€
âœ… æ¶æ„å®Œæ•´ï¼ŒåŠŸèƒ½é½å…¨  
âœ… ä»£ç è´¨é‡è‰¯å¥½  
âš ï¸ éƒ¨åˆ†æ¨¡å—éœ€è¦ä¼˜åŒ–  
âš ï¸ ç¼ºå°‘çœŸå®åŠ å¯†é›†æˆ  

### ä¼˜åŒ–æ–¹å‘
1. **åŠ å¯†æ¨¡å—**: é›†æˆçœŸå® BBS+ WASM åº“
2. **å­˜å‚¨ä¼˜åŒ–**: ç®€åŒ– IndexedDB å°è£…
3. **API ä¼˜åŒ–**: ç»Ÿä¸€é”™è¯¯å¤„ç†
4. **çŠ¶æ€ç®¡ç†**: æ·»åŠ  Selector ä¼˜åŒ–
5. **æµ‹è¯•å®Œå–„**: æé«˜æµ‹è¯•è¦†ç›–ç‡

### é¢„æœŸæ•ˆæœ
ğŸš€ æ€§èƒ½æå‡ 30%  
ğŸ“¦ ä»£ç å‡å°‘ 20%  
âœ¨ ç”¨æˆ·ä½“éªŒæ›´å¥½  
ğŸ”’ å®‰å…¨æ€§æ›´é«˜

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0.0  
**åˆ›å»ºæ—¥æœŸ**: 2025-01-21  
**çŠ¶æ€**: âœ… å·²å®Œæˆ
