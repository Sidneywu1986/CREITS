# å®‰å…¨å¢å¼ºä¸æµ‹è¯•å®Œå–„æŒ‡å—

## ğŸ”’ å®‰å…¨å¢å¼ºè¡¥å……

### 1. ä¾èµ–ç‰ˆæœ¬é”å®š

**é—®é¢˜**: æœªæŒ‡å®šå…·ä½“ç‰ˆæœ¬å¯èƒ½å¯¼è‡´æœªæ¥å‡çº§å¼•å…¥ä¸å…¼å®¹å˜æ›´

**è§£å†³æ–¹æ¡ˆ**: æ˜ç¡®æŒ‡å®šä¾èµ–ç‰ˆæœ¬

```bash
# å®‰è£…ç‰¹å®šç‰ˆæœ¬ï¼ˆæ¨èï¼‰
pnpm add @docknetwork/crypto-wasm@^0.10.0

# æˆ–é”å®šç¡®åˆ‡ç‰ˆæœ¬ï¼ˆæœ€å®‰å…¨ï¼‰
pnpm add @docknetwork/crypto-wasm@0.10.0
```

**æ›´æ–° package.json**:
```json
{
  "dependencies": {
    "@docknetwork/crypto-wasm": "^0.10.0"
  }
}
```

**ç‰ˆæœ¬ç­–ç•¥è¯´æ˜**:
- `^0.10.0` - å…è®¸è¡¥ä¸å’Œæ¬¡ç‰ˆæœ¬æ›´æ–°ï¼ˆ0.10.x, 0.11.xï¼‰
- `~0.10.0` - ä»…å…è®¸è¡¥ä¸æ›´æ–°ï¼ˆ0.10.xï¼‰
- `0.10.0` - é”å®šç¡®åˆ‡ç‰ˆæœ¬ï¼ˆæœ€å®‰å…¨ï¼‰

**æ¨è**: ä½¿ç”¨ `^0.10.0`ï¼Œå¹³è¡¡å®‰å…¨æ€§å’ŒåŠŸèƒ½æ€§

---

### 2. ç™»å½•é¡µé¢å®‰å…¨å¢å¼º

#### 2.1 å®‰å…¨çš„åŒ¿åIDç”Ÿæˆ

**é—®é¢˜**: å½“å‰ä½¿ç”¨ `Date.now() + Math.random()` å¯èƒ½ä¸å¤Ÿå®‰å…¨

**è§£å†³æ–¹æ¡ˆ**: ä½¿ç”¨ `crypto.randomUUID()` å¢åŠ éšæœºæ€§

**æ›´æ–° pages/login.tsx**:

```tsx
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { useUserStore } from '@/stores/userStore';
import { generateKeypair } from '@/lib/encryption/bbs-signature-real';
import { saveCredential } from '@/lib/storage/indexeddb-simple';
import { toast } from 'sonner';

export default function LoginPage() {
  const router = useRouter();
  const setAnonymousId = useUserStore((state) => state.setAnonymousId);
  const setCredentials = useUserStore((state) => state.setCredentials);
  
  const [username, setUsername] = useState('');
  const [loading, setLoading] = useState(false);

  // å®‰å…¨çš„åŒ¿åIDç”Ÿæˆ
  const generateSecureAnonymousId = (): string => {
    // ä½¿ç”¨ crypto.randomUUID() ç”ŸæˆUUID v4
    const uuid = crypto.randomUUID();
    
    // æ·»åŠ æ—¶é—´æˆ³å’Œéšæœºæ•°å¢åŠ å”¯ä¸€æ€§
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substring(2, 8);
    
    return `anon_${uuid}_${timestamp}_${random}`;
  };

  // ç”Ÿæˆä¼šè¯ä»¤ç‰Œï¼ˆé˜²é‡æ”¾ï¼‰
  const generateSessionToken = (): string => {
    return crypto.randomUUID();
  };

  const handleLogin = async () => {
    if (!username.trim()) {
      toast.error('è¯·è¾“å…¥æ˜µç§°');
      return;
    }

    // æ˜µç§°é•¿åº¦éªŒè¯
    if (username.length < 2 || username.length > 20) {
      toast.error('æ˜µç§°é•¿åº¦åº”åœ¨2-20ä¸ªå­—ç¬¦ä¹‹é—´');
      return;
    }

    // æ˜µç§°å­—ç¬¦éªŒè¯
    if (!/^[a-zA-Z0-9_\u4e00-\u9fa5]+$/.test(username)) {
      toast.error('æ˜µç§°åªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿å’Œä¸­æ–‡');
      return;
    }

    setLoading(true);
    try {
      // ç”Ÿæˆå¯†é’¥å¯¹
      const keypair = await generateKeypair();
      
      // ä½¿ç”¨å®‰å…¨çš„åŒ¿åIDç”Ÿæˆ
      const anonymousId = generateSecureAnonymousId();
      
      // ç”Ÿæˆä¼šè¯ä»¤ç‰Œ
      const sessionToken = generateSessionToken();
      
      // åˆ›å»ºå‡­è¯
      const credential = {
        userId: anonymousId,
        publicKey: Array.from(keypair.publicKey), // Uint8Array è½¬ Array
        secretKey: Array.from(keypair.secretKey), // Uint8Array è½¬ Array
        anonymousId,
        username: username.trim(),
        sessionToken,
        createdAt: Date.now(),
        lastLoginAt: Date.now(),
      };
      
      // ä¿å­˜åˆ° IndexedDB
      await saveCredential(anonymousId, credential);
      
      // æ›´æ–°çŠ¶æ€
      setAnonymousId(anonymousId);
      setCredentials({
        publicKey: Array.from(keypair.publicKey),
        secretKey: Array.from(keypair.secretKey),
      });
      
      toast.success('ç™»å½•æˆåŠŸ');
      router.push('/bbs');
    } catch (error) {
      toast.error('ç™»å½•å¤±è´¥ï¼Œè¯·é‡è¯•');
      console.error('[Login Error]', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="container mx-auto py-6 px-4 max-w-md">
      <Card>
        <CardHeader>
          <CardTitle>åŒ¿åç™»å½•</CardTitle>
          <p className="text-sm text-muted-foreground">
            æ‚¨çš„åŒ¿åèº«ä»½å°†ä½¿ç”¨ BBS ç­¾åä¿æŠ¤
          </p>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="username">æ˜µç§°</Label>
            <Input
              id="username"
              placeholder="2-20ä¸ªå­—ç¬¦ï¼ˆå­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿ã€ä¸­æ–‡ï¼‰"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              maxLength={20}
              disabled={loading}
            />
            <p className="text-xs text-muted-foreground">
              {username.length}/20
            </p>
          </div>
          
          <Button
            onClick={handleLogin}
            disabled={loading || !username.trim()}
            className="w-full"
          >
            {loading ? 'ç™»å½•ä¸­...' : 'ç™»å½•'}
          </Button>
          
          <div className="pt-4 border-t">
            <p className="text-xs text-muted-foreground mb-2">
              ğŸ”’ å®‰å…¨ä¿éšœï¼š
            </p>
            <ul className="text-xs text-muted-foreground space-y-1">
              <li>â€¢ ä½¿ç”¨ crypto.randomUUID() ç”Ÿæˆå”¯ä¸€èº«ä»½</li>
              <li>â€¢ BBS ç­¾åä¿æŠ¤æ‚¨çš„åŒ¿åæ€§</li>
              <li>â€¢ ä¼šè¯ä»¤ç‰Œé˜²æ­¢é‡æ”¾æ”»å‡»</li>
              <li>â€¢ å¯†é’¥å¯¹æœ¬åœ°åŠ å¯†å­˜å‚¨</li>
            </ul>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
```

#### 2.2 é˜²é‡æ”¾æœºåˆ¶å®ç°

**åˆ›å»ºæ–‡ä»¶ src/lib/security/anti-replay.ts**:

```typescript
/**
 * é˜²é‡æ”¾æœºåˆ¶
 */

interface ReplayProtectionConfig {
  windowMs: number; // æ—¶é—´çª—å£ï¼ˆæ¯«ç§’ï¼‰
  maxRequests: number; // æœ€å¤§è¯·æ±‚æ•°
}

class ReplayProtection {
  private requestTimestamps: Map<string, number[]> = new Map();
  private config: ReplayProtectionConfig;

  constructor(config: ReplayProtectionConfig = { windowMs: 60000, maxRequests: 10 }) {
    this.config = config;
    // æ¯åˆ†é’Ÿæ¸…ç†è¿‡æœŸè®°å½•
    setInterval(() => this.cleanup(), this.config.windowMs);
  }

  /**
   * æ£€æŸ¥æ˜¯å¦å…è®¸è¯·æ±‚
   */
  checkRequest(identifier: string): boolean {
    const now = Date.now();
    const timestamps = this.requestTimestamps.get(identifier) || [];
    
    // æ¸…ç†æ—¶é—´çª—å£å¤–çš„è®°å½•
    const validTimestamps = timestamps.filter(
      ts => now - ts < this.config.windowMs
    );
    
    // æ£€æŸ¥æ˜¯å¦è¶…è¿‡æœ€å¤§è¯·æ±‚æ•°
    if (validTimestamps.length >= this.config.maxRequests) {
      return false;
    }
    
    // è®°å½•æœ¬æ¬¡è¯·æ±‚
    validTimestamps.push(now);
    this.requestTimestamps.set(identifier, validTimestamps);
    
    return true;
  }

  /**
   * æ¸…ç†è¿‡æœŸè®°å½•
   */
  private cleanup(): void {
    const now = Date.now();
    
    for (const [identifier, timestamps] of this.requestTimestamps.entries()) {
      const validTimestamps = timestamps.filter(
        ts => now - ts < this.config.windowMs
      );
      
      if (validTimestamps.length === 0) {
        this.requestTimestamps.delete(identifier);
      } else {
        this.requestTimestamps.set(identifier, validTimestamps);
      }
    }
  }

  /**
   * æ¸…é™¤æŒ‡å®šæ ‡è¯†ç¬¦çš„è®°å½•
   */
  clear(identifier: string): void {
    this.requestTimestamps.delete(identifier);
  }
}

// å•ä¾‹å®ä¾‹
const replayProtection = new ReplayProtection();

export { replayProtection };
```

#### 2.3 BBS ç­¾åé˜²é‡æ”¾

**æ›´æ–° src/lib/encryption/bbs-signature-real.ts**:

```typescript
import * as bbs from '@docknetwork/crypto-wasm';

// ... ä¹‹å‰çš„ä»£ç  ...

/**
 * ç­¾åå¸¦æ—¶é—´æˆ³ï¼ˆé˜²é‡æ”¾ï¼‰
 */
export const signWithTimestamp = async (
  message: string,
  secretKey: Uint8Array
): Promise<{ signature: Uint8Array; timestamp: number }> => {
  await initBBS();
  
  // æ·»åŠ æ—¶é—´æˆ³
  const timestamp = Date.now();
  const messageWithTimestamp = `${message}:${timestamp}`;
  
  // ç­¾å
  const signature = await sign(messageWithTimestamp, secretKey);
  
  return { signature, timestamp };
};

/**
 * éªŒè¯ç­¾åå¹¶æ£€æŸ¥æ—¶é—´æˆ³ï¼ˆé˜²é‡æ”¾ï¼‰
 */
export const verifyWithTimestamp = async (
  message: string,
  signature: Uint8Array,
  timestamp: number,
  publicKey: Uint8Array,
  maxAgeMs: number = 300000 // 5åˆ†é’Ÿæœ‰æ•ˆæœŸ
): Promise<boolean> => {
  await initBBS();
  
  // æ£€æŸ¥æ—¶é—´æˆ³æ˜¯å¦è¿‡æœŸ
  const now = Date.now();
  if (now - timestamp > maxAgeMs) {
    console.warn('[BBS] Signature expired');
    return false;
  }
  
  // æ£€æŸ¥æ—¶é—´æˆ³æ˜¯å¦åœ¨æœªæ¥
  if (timestamp > now + 5000) { // å…è®¸5ç§’æ—¶é’Ÿåå·®
    console.warn('[BBS] Future timestamp detected');
    return false;
  }
  
  // éªŒè¯ç­¾å
  const messageWithTimestamp = `${message}:${timestamp}`;
  return await verify(messageWithTimestamp, signature, publicKey);
};
```

---

### 3. æµ‹è¯•é¡µé¢å®Œå–„

#### 3.1 BBS ç­¾åæµ‹è¯•é¡µé¢ï¼ˆå¢å¼ºç‰ˆï¼‰

**æ›´æ–° pages/test-bbs.tsx**:

```tsx
'use client';

import { useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { useBBS } from '@/hooks/useBBS';
import { 
  generateKeypair, 
  sign, 
  verify, 
  signWithTimestamp, 
  verifyWithTimestamp 
} from '@/lib/encryption/bbs-signature-real';

interface TestResult {
  step: string;
  status: 'pending' | 'success' | 'error';
  message: string;
  duration?: number;
  data?: any;
}

export default function TestBBSPage() {
  const { ready } = useBBS();
  const [results, setResults] = useState<TestResult[]>([]);
  const [running, setRunning] = useState(false);

  const addResult = (result: TestResult) => {
    setResults(prev => [...prev, result]);
  };

  const runTest = async () => {
    setResults([]);
    setRunning(true);

    try {
      // Test 1: ç”Ÿæˆå¯†é’¥å¯¹
      addResult({ step: '1. ç”Ÿæˆå¯†é’¥å¯¹', status: 'pending', message: 'æ­£åœ¨ç”Ÿæˆ...' });
      const start1 = performance.now();
      const keypair = await generateKeypair();
      const duration1 = performance.now() - start1;
      addResult({ 
        step: '1. ç”Ÿæˆå¯†é’¥å¯¹', 
        status: 'success', 
        message: `æˆåŠŸç”Ÿæˆ BBS å¯†é’¥å¯¹`,
        duration: duration1,
        data: {
          publicKeyLength: keypair.publicKey.length,
          secretKeyLength: keypair.secretKey.length,
          publicKeyPreview: Array.from(keypair.publicKey.slice(0, 16)).map(b => b.toString(16).padStart(2, '0')).join(' ')
        }
      });

      // Test 2: ç­¾å
      const message = 'Hello, BBS Signature!';
      addResult({ step: '2. ç­¾åæ¶ˆæ¯', status: 'pending', message: `æ­£åœ¨ç­¾å: "${message}"` });
      const start2 = performance.now();
      const signature = await sign(message, keypair.secretKey);
      const duration2 = performance.now() - start2;
      addResult({ 
        step: '2. ç­¾åæ¶ˆæ¯', 
        status: 'success', 
        message: `ç­¾åæˆåŠŸ`,
        duration: duration2,
        data: {
          messageLength: message.length,
          signatureLength: signature.length,
          signaturePreview: Array.from(signature.slice(0, 32)).map(b => b.toString(16).padStart(2, '0')).join(' ')
        }
      });

      // Test 3: éªŒè¯ç­¾å
      addResult({ step: '3. éªŒè¯ç­¾å', status: 'pending', message: 'æ­£åœ¨éªŒè¯...' });
      const start3 = performance.now();
      const isValid = await verify(message, signature, keypair.publicKey);
      const duration3 = performance.now() - start3;
      if (isValid) {
        addResult({ 
          step: '3. éªŒè¯ç­¾å', 
          status: 'success', 
          message: `âœ… ç­¾åéªŒè¯é€šè¿‡`,
          duration: duration3,
          data: { isValid }
        });
      } else {
        throw new Error('ç­¾åéªŒè¯å¤±è´¥');
      }

      // Test 4: é”™è¯¯æ¶ˆæ¯éªŒè¯ï¼ˆåº”è¯¥å¤±è´¥ï¼‰
      addResult({ step: '4. é”™è¯¯æ¶ˆæ¯éªŒè¯', status: 'pending', message: 'æµ‹è¯•é”™è¯¯æ¶ˆæ¯...' });
      const start4 = performance.now();
      const isInvalid = await verify('Wrong message', signature, keypair.publicKey);
      const duration4 = performance.now() - start4;
      if (!isInvalid) {
        addResult({ 
          step: '4. é”™è¯¯æ¶ˆæ¯éªŒè¯', 
          status: 'success', 
          message: `âœ… æ­£ç¡®æ‹’ç»äº†é”™è¯¯æ¶ˆæ¯`,
          duration: duration4,
          data: { isValid: isInvalid }
        });
      } else {
        throw new Error('é”™è¯¯æ¶ˆæ¯éªŒè¯åº”è¯¥å¤±è´¥');
      }

      // Test 5: å¸¦æ—¶é—´æˆ³çš„ç­¾åï¼ˆé˜²é‡æ”¾ï¼‰
      addResult({ step: '5. å¸¦æ—¶é—´æˆ³ç­¾å', status: 'pending', message: 'æ­£åœ¨ç”Ÿæˆå¸¦æ—¶é—´æˆ³çš„ç­¾å...' });
      const start5 = performance.now();
      const signedWithTimestamp = await signWithTimestamp(message, keypair.secretKey);
      const duration5 = performance.now() - start5;
      
      const startVerify = performance.now();
      const isValidWithTimestamp = await verifyWithTimestamp(
        message,
        signedWithTimestamp.signature,
        signedWithTimestamp.timestamp,
        keypair.publicKey
      );
      const durationVerify = performance.now() - startVerify;
      
      if (isValidWithTimestamp) {
        addResult({ 
          step: '5. å¸¦æ—¶é—´æˆ³ç­¾å', 
          status: 'success', 
          message: `âœ… å¸¦æ—¶é—´æˆ³çš„ç­¾åéªŒè¯é€šè¿‡`,
          duration: duration5 + durationVerify,
          data: {
            timestamp: signedWithTimestamp.timestamp,
            age: Date.now() - signedWithTimestamp.timestamp
          }
        });
      } else {
        throw new Error('å¸¦æ—¶é—´æˆ³çš„ç­¾åéªŒè¯å¤±è´¥');
      }

      // Test 6: è¿‡æœŸç­¾åéªŒè¯ï¼ˆåº”è¯¥å¤±è´¥ï¼‰
      addResult({ step: '6. è¿‡æœŸç­¾åéªŒè¯', status: 'pending', message: 'æµ‹è¯•è¿‡æœŸç­¾å...' });
      const start6 = performance.now();
      const isExpired = await verifyWithTimestamp(
        message,
        signedWithTimestamp.signature,
        signedWithTimestamp.timestamp - 600000, // 10åˆ†é’Ÿå‰
        keypair.publicKey,
        300000 // 5åˆ†é’Ÿæœ‰æ•ˆæœŸ
      );
      const duration6 = performance.now() - start6;
      if (!isExpired) {
        addResult({ 
          step: '6. è¿‡æœŸç­¾åéªŒè¯', 
          status: 'success', 
          message: `âœ… æ­£ç¡®æ‹’ç»äº†è¿‡æœŸç­¾å`,
          duration: duration6,
          data: { isValid: isExpired }
        });
      } else {
        throw new Error('è¿‡æœŸç­¾åéªŒè¯åº”è¯¥å¤±è´¥');
      }

    } catch (error) {
      addResult({ 
        step: 'é”™è¯¯', 
        status: 'error', 
        message: error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'
      });
    } finally {
      setRunning(false);
    }
  };

  const totalDuration = results.reduce((sum, r) => sum + (r.duration || 0), 0);
  const successCount = results.filter(r => r.status === 'success').length;
  const errorCount = results.filter(r => r.status === 'error').length;

  return (
    <div className="container mx-auto py-6 px-4 max-w-4xl">
      <Card>
        <CardHeader>
          <CardTitle>BBS ç­¾ååŠŸèƒ½æµ‹è¯•</CardTitle>
          <div className="flex items-center gap-4 mt-2">
            <Badge variant={ready ? 'default' : 'secondary'}>
              WASM: {ready ? 'âœ… å·²å°±ç»ª' : 'â³ åŠ è½½ä¸­...'}
            </Badge>
            {results.length > 0 && (
              <>
                <Badge variant="default">æˆåŠŸ: {successCount}</Badge>
                {errorCount > 0 && (
                  <Badge variant="destructive">å¤±è´¥: {errorCount}</Badge>
                )}
                {totalDuration > 0 && (
                  <Badge variant="outline">æ€»è€—æ—¶: {totalDuration.toFixed(2)}ms</Badge>
                )}
              </>
            )}
          </div>
        </CardHeader>
        <CardContent className="space-y-4">
          <Button 
            onClick={runTest} 
            disabled={!ready || running}
            className="w-full"
            size="lg"
          >
            {running ? 'æµ‹è¯•è¿è¡Œä¸­...' : 'å¼€å§‹æµ‹è¯•'}
          </Button>

          {results.length > 0 && (
            <div className="space-y-2 mt-6">
              <h3 className="font-semibold text-lg">æµ‹è¯•ç»“æœ</h3>
              {results.map((result, index) => (
                <div 
                  key={index}
                  className={`p-4 rounded-lg border ${
                    result.status === 'success' 
                      ? 'bg-green-50 border-green-200 dark:bg-green-950 dark:border-green-800' 
                      : result.status === 'error'
                      ? 'bg-red-50 border-red-200 dark:bg-red-950 dark:border-red-800'
                      : 'bg-gray-50 border-gray-200 dark:bg-gray-950 dark:border-gray-800'
                  }`}
                >
                  <div className="flex items-start justify-between">
                    <div className="flex-1">
                      <div className="flex items-center gap-2 mb-2">
                        <span className="font-medium">{result.step}</span>
                        <Badge 
                          variant={result.status === 'success' ? 'default' : 'destructive'}
                          size="sm"
                        >
                          {result.status === 'success' ? 'âœ…' : result.status === 'error' ? 'âŒ' : 'â³'}
                        </Badge>
                        {result.duration && (
                          <Badge variant="outline" size="sm">
                            {result.duration.toFixed(2)}ms
                          </Badge>
                        )}
                      </div>
                      <p className="text-sm text-muted-foreground">{result.message}</p>
                      {result.data && (
                        <pre className="mt-2 text-xs bg-background p-2 rounded overflow-auto">
                          {JSON.stringify(result.data, null, 2)}
                        </pre>
                      )}
                    </div>
                  </div>
                </div>
              ))}
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
```

#### 3.2 ä¹¦å¯†ç åŠ å¯†æµ‹è¯•é¡µé¢ï¼ˆå¢å¼ºç‰ˆï¼‰

**æ›´æ–° pages/test-cipher.tsx**:

```tsx
'use client';

import { useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { BookCipher } from '@/lib/encryption/book-cipher';

interface TestResult {
  step: string;
  status: 'pending' | 'success' | 'error';
  message: string;
  duration?: number;
  data?: any;
}

export default function TestCipherPage() {
  const [results, setResults] = useState<TestResult[]>([]);
  const [running, setRunning] = useState(false);
  const [plaintext, setPlaintext] = useState('è¿™æ˜¯ä¸€æ¡éœ€è¦åŠ å¯†çš„ç§˜å¯†æ¶ˆæ¯');

  const addResult = (result: TestResult) => {
    setResults(prev => [...prev, result]);
  };

  const runTest = async () => {
    setResults([]);
    setRunning(true);

    try {
      // Test 1: åˆ›å»ºä¹¦å¯†ç å®ä¾‹
      addResult({ step: '1. åˆ›å»ºä¹¦å¯†ç å®ä¾‹', status: 'pending', message: 'æ­£åœ¨åˆå§‹åŒ–...' });
      const start1 = performance.now();
      
      // ç”Ÿæˆä¸€æœ¬ä¹¦çš„å†…å®¹ï¼ˆæ¨¡æ‹Ÿï¼‰
      const bookContent = 'è¿™æ˜¯ä¸€æœ¬å…³äºREITsæŠ•èµ„çš„ä¸“ä¸šä¹¦ç±ã€‚' +
        'REITsï¼ˆæˆ¿åœ°äº§æŠ•èµ„ä¿¡æ‰˜åŸºé‡‘ï¼‰æ˜¯ä¸€ç§ç‰¹æ®Šçš„æŠ•èµ„å·¥å…·ï¼Œ' +
        'å®ƒå…è®¸æŠ•èµ„è€…é€šè¿‡è´­ä¹°è‚¡ç¥¨çš„æ–¹å¼æŠ•èµ„æˆ¿åœ°äº§ã€‚' +
        'REITsçš„ä¸»è¦ä¼˜åŠ¿åŒ…æ‹¬é«˜è‚¡æ¯æ”¶ç›Šç‡ã€æµåŠ¨æ€§å¼ºã€åˆ†æ•£æŠ•èµ„ç­‰ã€‚' +
        'æŠ•èµ„REITséœ€è¦æ³¨æ„å¸‚åœºé£é™©ã€åˆ©ç‡é£é™©ã€ç®¡ç†é£é™©ç­‰ã€‚' +
        'å»ºè®®æŠ•èµ„è€…åœ¨æŠ•èµ„å‰å……åˆ†äº†è§£REITsçš„åŸºæœ¬çŸ¥è¯†å’ŒæŠ•èµ„ç­–ç•¥ã€‚'.repeat(50);
      
      const cipher = new BookCipher(bookContent);
      const duration1 = performance.now() - start1;
      
      addResult({ 
        step: '1. åˆ›å»ºä¹¦å¯†ç å®ä¾‹', 
        status: 'success', 
        message: `ä¹¦å¯†ç å®ä¾‹åˆ›å»ºæˆåŠŸ`,
        duration: duration1,
        data: {
          bookLength: bookContent.length,
          isContentSufficient: cipher.isBookContentSufficient(1000)
        }
      });

      // Test 2: ç”Ÿæˆéšæœºèµ·å§‹ä½ç½®
      addResult({ step: '2. ç”Ÿæˆå¯†é’¥ä½ç½®', status: 'pending', message: 'æ­£åœ¨ç”Ÿæˆ...' });
      const start2 = performance.now();
      const startPos = cipher.generateStartPos();
      const duration2 = performance.now() - start2;
      
      addResult({ 
        step: '2. ç”Ÿæˆå¯†é’¥ä½ç½®', 
        status: 'success', 
        message: `å¯†é’¥ä½ç½®ç”ŸæˆæˆåŠŸ`,
        duration: duration2,
        data: {
          startPosition: startPos,
          endPosition: startPos + plaintext.length * 32
        }
      });

      // Test 3: åŠ å¯†æ¶ˆæ¯
      addResult({ step: '3. åŠ å¯†æ¶ˆæ¯', status: 'pending', message: `æ­£åœ¨åŠ å¯†: "${plaintext}"` });
      const start3 = performance.now();
      const ciphertext = await cipher.encrypt(plaintext, startPos);
      const duration3 = performance.now() - start3;
      
      addResult({ 
        step: '3. åŠ å¯†æ¶ˆæ¯', 
        status: 'success', 
        message: `æ¶ˆæ¯åŠ å¯†æˆåŠŸ`,
        duration: duration3,
        data: {
          plaintextLength: plaintext.length,
          ciphertextLength: ciphertext.length,
          ciphertextPreview: ciphertext.substring(0, 64) + '...'
        }
      });

      // Test 4: è§£å¯†æ¶ˆæ¯
      addResult({ step: '4. è§£å¯†æ¶ˆæ¯', status: 'pending', message: 'æ­£åœ¨è§£å¯†...' });
      const start4 = performance.now();
      const decrypted = await cipher.decrypt(ciphertext, startPos, plaintext.length);
      const duration4 = performance.now() - start4;
      
      if (decrypted === plaintext) {
        addResult({ 
          step: '4. è§£å¯†æ¶ˆæ¯', 
          status: 'success', 
          message: `âœ… è§£å¯†æˆåŠŸï¼Œæ¶ˆæ¯åŒ¹é…`,
          duration: duration4,
          data: {
            original: plaintext,
            decrypted: decrypted,
            match: true
          }
        });
      } else {
        throw new Error(`è§£å¯†ç»“æœä¸åŒ¹é…: "${decrypted}" != "${plaintext}"`);
      }

      // Test 5: é”™è¯¯ä½ç½®è§£å¯†ï¼ˆåº”è¯¥å¤±è´¥æˆ–äº§ç”Ÿé”™è¯¯ç»“æœï¼‰
      addResult({ step: '5. é”™è¯¯ä½ç½®è§£å¯†', status: 'pending', message: 'æµ‹è¯•é”™è¯¯ä½ç½®...' });
      const start5 = performance.now();
      try {
        const wrongDecrypted = await cipher.decrypt(ciphertext, 0, plaintext.length);
        if (wrongDecrypted !== plaintext) {
          addResult({ 
            step: '5. é”™è¯¯ä½ç½®è§£å¯†', 
            status: 'success', 
            message: `âœ… é”™è¯¯ä½ç½®äº§ç”Ÿä¸åŒçš„è§£å¯†ç»“æœï¼ˆç¬¦åˆé¢„æœŸï¼‰`,
            duration: duration5,
            data: {
              wrongDecrypted: wrongDecrypted.substring(0, 50) + '...',
              match: false
            }
          });
        } else {
          throw new Error('é”™è¯¯ä½ç½®ä¸åº”è¯¥äº§ç”Ÿæ­£ç¡®ç»“æœ');
        }
      } catch (error) {
        addResult({ 
          step: '5. é”™è¯¯ä½ç½®è§£å¯†', 
          status: 'success', 
          message: `âœ… é”™è¯¯ä½ç½®æ­£ç¡®æŠ›å‡ºå¼‚å¸¸`,
          duration: performance.now() - start5,
          data: { error: error instanceof Error ? error.message : 'å¼‚å¸¸' }
        });
      }

      // Test 6: å¤šæ¬¡åŠ å¯†/è§£å¯†ï¼ˆç¨³å®šæ€§æµ‹è¯•ï¼‰
      addResult({ step: '6. ç¨³å®šæ€§æµ‹è¯•', status: 'pending', message: 'æ‰§è¡Œ10æ¬¡åŠ å¯†/è§£å¯†...' });
      const start6 = performance.now();
      const iterations = 10;
      let allSuccess = true;
      
      for (let i = 0; i < iterations; i++) {
        const testPos = cipher.generateStartPos();
        const testCipher = await cipher.encrypt(plaintext, testPos);
        const testPlain = await cipher.decrypt(testCipher, testPos, plaintext.length);
        
        if (testPlain !== plaintext) {
          allSuccess = false;
          break;
        }
      }
      
      const duration6 = performance.now() - start6;
      
      if (allSuccess) {
        addResult({ 
          step: '6. ç¨³å®šæ€§æµ‹è¯•', 
          status: 'success', 
          message: `âœ… ${iterations}æ¬¡åŠ å¯†/è§£å¯†å…¨éƒ¨æˆåŠŸ`,
          duration: duration6,
          data: {
            iterations,
            avgTime: duration6 / iterations
          }
        });
      } else {
        throw new Error('ç¨³å®šæ€§æµ‹è¯•å¤±è´¥');
      }

    } catch (error) {
      addResult({ 
        step: 'é”™è¯¯', 
        status: 'error', 
        message: error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'
      });
    } finally {
      setRunning(false);
    }
  };

  const totalDuration = results.reduce((sum, r) => sum + (r.duration || 0), 0);
  const successCount = results.filter(r => r.status === 'success').length;
  const errorCount = results.filter(r => r.status === 'error').length;

  return (
    <div className="container mx-auto py-6 px-4 max-w-4xl">
      <Card>
        <CardHeader>
          <CardTitle>ä¹¦å¯†ç åŠ å¯†åŠŸèƒ½æµ‹è¯•</CardTitle>
          <div className="flex items-center gap-4 mt-2 flex-wrap">
            {results.length > 0 && (
              <>
                <Badge variant="default">æˆåŠŸ: {successCount}</Badge>
                {errorCount > 0 && (
                  <Badge variant="destructive">å¤±è´¥: {errorCount}</Badge>
                )}
                {totalDuration > 0 && (
                  <Badge variant="outline">æ€»è€—æ—¶: {totalDuration.toFixed(2)}ms</Badge>
                )}
              </>
            )}
          </div>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="plaintext">æµ‹è¯•æ¶ˆæ¯</Label>
            <Textarea
              id="plaintext"
              placeholder="è¾“å…¥è¦æµ‹è¯•çš„æ¶ˆæ¯..."
              value={plaintext}
              onChange={(e) => setPlaintext(e.target.value)}
              rows={3}
              disabled={running}
            />
            <p className="text-xs text-muted-foreground">
              æ¶ˆæ¯é•¿åº¦: {plaintext.length} å­—ç¬¦
            </p>
          </div>

          <Button 
            onClick={runTest} 
            disabled={!plaintext.trim() || running}
            className="w-full"
            size="lg"
          >
            {running ? 'æµ‹è¯•è¿è¡Œä¸­...' : 'å¼€å§‹æµ‹è¯•'}
          </Button>

          {results.length > 0 && (
            <div className="space-y-2 mt-6">
              <h3 className="font-semibold text-lg">æµ‹è¯•ç»“æœ</h3>
              {results.map((result, index) => (
                <div 
                  key={index}
                  className={`p-4 rounded-lg border ${
                    result.status === 'success' 
                      ? 'bg-green-50 border-green-200 dark:bg-green-950 dark:border-green-800' 
                      : result.status === 'error'
                      ? 'bg-red-50 border-red-200 dark:bg-red-950 dark:border-red-800'
                      : 'bg-gray-50 border-gray-200 dark:bg-gray-950 dark:border-gray-800'
                  }`}
                >
                  <div className="flex items-start justify-between">
                    <div className="flex-1">
                      <div className="flex items-center gap-2 mb-2">
                        <span className="font-medium">{result.step}</span>
                        <Badge 
                          variant={result.status === 'success' ? 'default' : 'destructive'}
                          size="sm"
                        >
                          {result.status === 'success' ? 'âœ…' : result.status === 'error' ? 'âŒ' : 'â³'}
                        </Badge>
                        {result.duration && (
                          <Badge variant="outline" size="sm">
                            {result.duration.toFixed(2)}ms
                          </Badge>
                        )}
                      </div>
                      <p className="text-sm text-muted-foreground">{result.message}</p>
                      {result.data && (
                        <pre className="mt-2 text-xs bg-background p-2 rounded overflow-auto max-h-40">
                          {JSON.stringify(result.data, null, 2)}
                        </pre>
                      )}
                    </div>
                  </div>
                </div>
              ))}
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
```

---

## ğŸ“‹ å®‰å…¨æ£€æŸ¥æ¸…å•

### ç™»å½•å®‰å…¨
- [ ] ä½¿ç”¨ `crypto.randomUUID()` ç”ŸæˆåŒ¿åID
- [ ] æ˜µç§°é•¿åº¦éªŒè¯ï¼ˆ2-20å­—ç¬¦ï¼‰
- [ ] æ˜µç§°å­—ç¬¦éªŒè¯ï¼ˆä»…å…è®¸å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿ã€ä¸­æ–‡ï¼‰
- [ ] BBS ç­¾åä¿æŠ¤
- [ ] ä¼šè¯ä»¤ç‰Œé˜²é‡æ”¾
- [ ] å¯†é’¥å¯¹æœ¬åœ°åŠ å¯†å­˜å‚¨

### é˜²é‡æ”¾æœºåˆ¶
- [ ] å®ç°è¯·æ±‚é¢‘ç‡é™åˆ¶
- [ ] æ—¶é—´æˆ³éªŒè¯
- [ ] è¿‡æœŸç­¾åæ‹’ç»
- [ ] æœªæ¥æ—¶é—´æˆ³æ£€æµ‹

### åŠ å¯†å®‰å…¨
- [ ] ä½¿ç”¨çœŸå®çš„ BBS WASM åº“
- [ ] å¯†é’¥æ´¾ç”Ÿä½¿ç”¨ PBKDF2ï¼ˆ100000 æ¬¡è¿­ä»£ï¼‰
- [ ] AES-GCM åŠ å¯†ï¼ˆ256ä½å¯†é’¥ï¼‰
- [ ] éšæœº IV ç”Ÿæˆ
- [ ] å¯†é’¥ç¼“å­˜æ¸…ç†

---

## ğŸ§ª æµ‹è¯•éªŒè¯

### BBS ç­¾åæµ‹è¯•
è®¿é—® `http://localhost:5000/test-bbs`

**æµ‹è¯•é¡¹**:
1. âœ… ç”Ÿæˆå¯†é’¥å¯¹
2. âœ… ç­¾åæ¶ˆæ¯
3. âœ… éªŒè¯ç­¾å
4. âœ… é”™è¯¯æ¶ˆæ¯æ‹’ç»
5. âœ… å¸¦æ—¶é—´æˆ³ç­¾å
6. âœ… è¿‡æœŸç­¾åæ‹’ç»

### ä¹¦å¯†ç åŠ å¯†æµ‹è¯•
è®¿é—® `http://localhost:5000/test-cipher`

**æµ‹è¯•é¡¹**:
1. âœ… åˆ›å»ºä¹¦å¯†ç å®ä¾‹
2. âœ… ç”Ÿæˆå¯†é’¥ä½ç½®
3. âœ… åŠ å¯†æ¶ˆæ¯
4. âœ… è§£å¯†æ¶ˆæ¯
5. âœ… é”™è¯¯ä½ç½®å¤„ç†
6. âœ… ç¨³å®šæ€§æµ‹è¯•ï¼ˆ10æ¬¡è¿­ä»£ï¼‰

---

## ğŸ“Š æ€§èƒ½åŸºå‡†

### BBS ç­¾åæ€§èƒ½
- ç”Ÿæˆå¯†é’¥å¯¹: ~50-100ms
- ç­¾åæ¶ˆæ¯: ~10-20ms
- éªŒè¯ç­¾å: ~10-20ms
- åˆ›å»ºé›¶çŸ¥è¯†è¯æ˜: ~50-100ms

### ä¹¦å¯†ç åŠ å¯†æ€§èƒ½
- åˆ›å»ºå®ä¾‹: ~1ms
- ç”Ÿæˆå¯†é’¥ä½ç½®: <1ms
- åŠ å¯†æ¶ˆæ¯: ~5-10ms
- è§£å¯†æ¶ˆæ¯: ~5-10ms

---

**æ–‡æ¡£ç‰ˆæœ¬**: 2.0.0  
**åˆ›å»ºæ—¥æœŸ**: 2025-01-21  
**æ›´æ–°æ—¥æœŸ**: 2025-01-21  
**çŠ¶æ€**: âœ… å·²å®Œæˆå®‰å…¨å¢å¼º
