# 金融数据实时更新与自动获取解决方案

## 一、数据源分析

### 1.1 官方数据源

| 数据类型 | 数据源 | 更新频率 | 数据格式 |
|---------|--------|---------|---------|
| REITs产品列表 | 上交所、深交所、证监会 | 每日 | HTML/JSON |
| 产品基本信息 | 交易所官网 | 实时 | JSON |
| 实时行情数据 | 交易所行情接口 | 实时（3秒） | WebSocket |
| 财务数据 | 季报/年报 | 季度 | PDF/XLSX |
| ABS产品列表 | 中国证券业协会 | 每日 | HTML/JSON |
| 新闻资讯 | 财经媒体API | 实时 | RSS/JSON |

### 1.2 第三方金融数据API（推荐）

| 服务商 | 优势 | 成本 | 适用场景 |
|--------|------|------|---------|
| Wind（万得） | 数据最全面，机构首选 | 高 | 专业机构 |
| 东方财富Choice | 数据丰富，价格适中 | 中 | 中等规模 |
| 同花顺iFinD | 接口友好，性价比高 | 中低 | 中小企业 |
| 新浪财经API | 免费，基础数据 | 免费 | 个人/小型项目 |
| Tushare（TuShare） | 免费，Python库友好 | 免费 | 个人开发 |

## 二、技术架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                         前端应用                            │
│  (Next.js + React + WebSocket Client)                       │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                      API Gateway                            │
│  (Next.js API Routes)                                       │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌──────────────┬──────────────┬──────────────┬──────────────┐
│  数据同步层   │  实时推送层   │  缓存层      │  数据存储层   │
│  (定时任务)   │  (WebSocket) │  (Redis)     │  (PostgreSQL)│
└──────────────┴──────────────┴──────────────┴──────────────┘
                              ↓
┌──────────────┬──────────────┬──────────────┐
│  交易所API   │  第三方API   │  爬虫系统    │
└──────────────┴──────────────┴──────────────┘
```

### 2.2 数据流程

**1. 定时同步流程**：
```
定时任务触发 → 调用数据源API → 解析数据 → 更新数据库 → 清除缓存
```

**2. 实时更新流程**：
```
数据源变化 → WebSocket推送 → 前端接收 → 更新UI → 更新缓存
```

**3. 用户请求流程**：
```
用户访问 → 检查缓存 → 缓存命中返回 → 缓存未命中查询数据库 → 更新缓存
```

## 三、实现方案

### 3.1 方案A：集成Tushare（推荐免费方案）

**优势**：
- ✅ 完全免费
- ✅ Python生态支持好
- ✅ 数据覆盖面广
- ✅ 有详细的API文档
- ✅ 社区活跃，问题容易解决

**支持的API**：
- REITs产品列表：`daily()`, `daily_basic()`
- 实时行情：`realtime_quotes()`, `get_realtime_quotes()`
- 财务数据：`fina_indicator()`, `income()`, `balancesheet()`
- 新闻资讯：`news()`, `guba_sina()`

**代码示例**：

```python
# 服务端：lib/services/tushare-service.ts
import Tushare from 'tushare-node';

export class TushareService {
  private client: Tushare;
  
  constructor(apiToken: string) {
    this.client = new Tushare(apiToken);
  }

  // 获取REITs产品列表
  async getREITsList() {
    const data = await this.client.daily({
      ts_code: 'REITs相关代码',
      start_date: this.formatDate(new Date()),
    });
    return this.transformToProductList(data);
  }

  // 获取实时行情
  async getRealtimeQuotes(codes: string[]) {
    const data = await this.client.get_realtime_quotes({
      ts_code: codes.join(','),
    });
    return this.transformToQuotes(data);
  }

  // 获取财务数据
  async getFinancialData(code: string) {
    const income = await this.client.income({ ts_code: code });
    const balance = await this.client.balancesheet({ ts_code: code });
    return {
      totalRevenue: income.total_revenue,
      netProfit: income.net_profit,
      totalAssets: balance.total_assets,
      totalLiabilities: balance.total_liability,
    };
  }
}
```

### 3.2 方案B：自建爬虫系统

**适用场景**：
- 需要定制化数据
- 需要从多个数据源聚合
- 对数据格式有特殊要求

**技术栈**：
- **Puppeteer/Playwright**：处理动态网页
- **Cheerio**：解析HTML
- **Axios**：HTTP请求
- **Node-cron**：定时任务

**代码示例**：

```typescript
// lib/services/sse-crawler.ts
import puppeteer from 'puppeteer';
import * as cheerio from 'cheerio';
import axios from 'axios';

export class SSECrawler {
  private baseUrl = 'http://www.sse.com.cn';

  async getREITsProducts() {
    const browser = await puppeteer.launch();
    const page = await browser.newPage();
    
    await page.goto(`${this.baseUrl}/disclosure/reits/`);
    await page.waitForSelector('.product-list');
    
    const data = await page.evaluate(() => {
      const items = document.querySelectorAll('.product-item');
      return Array.from(items).map(item => ({
        name: item.querySelector('.product-name')?.textContent,
        code: item.querySelector('.product-code')?.textContent,
        issueDate: item.querySelector('.issue-date')?.textContent,
      }));
    });
    
    await browser.close();
    return data;
  }

  async getNewsData() {
    const response = await axios.get('https://www.sse.com.cn/news/reits/');
    const $ = cheerio.load(response.data);
    
    return $('.news-item').map((_, item) => ({
      title: $(item).find('.title').text(),
      url: $(item).find('a').attr('href'),
      date: $(item).find('.date').text(),
    })).get();
  }
}
```

### 3.3 方案C：集成专业金融API（付费方案）

**推荐服务商**：
- 东方财富Choice：`https://api.eastmoney.com/`
- 同花顺iFinD：`https://api.10jqka.com.cn/`

**代码示例**：

```typescript
// lib/services/eastmoney-service.ts
import axios from 'axios';

export class EastMoneyService {
  private baseUrl = 'https://api.eastmoney.com';

  async getREITsList() {
    const response = await axios.get(`${this.baseUrl}/api/data/REITs/List`);
    return response.data.data;
  }

  async getRealtimeQuotes(codes: string[]) {
    const response = await axios.get(`${this.baseUrl}/api/stock/realtime`, {
      params: { codes: codes.join(',') }
    });
    return response.data.data;
  }

  async getFinancialData(code: string, period: string = '2024Q3') {
    const response = await axios.get(`${this.baseUrl}/api/finance/report`, {
      params: { code, period }
    });
    return response.data.data;
  }
}
```

## 四、定时任务实现

### 4.1 使用node-cron

```typescript
// lib/cron/data-sync-job.ts
import cron from 'node-cron';
import { TushareService } from '@/services/tushare-service';

export class DataSyncJob {
  private tushare: TushareService;

  constructor() {
    this.tushare = new TushareService(process.env.TUSHARE_TOKEN!);
  }

  start() {
    // 每天早上8点同步产品列表
    cron.schedule('0 8 * * *', () => this.syncProductList());
    
    // 每交易日15:30同步财务数据
    cron.schedule('30 15 * * 1-5', () => this.syncFinancialData());
    
    // 每5分钟同步实时行情
    cron.schedule('*/5 * * * *', () => this.syncQuotes());
    
    // 每小时同步新闻
    cron.schedule('0 * * * *', () => this.syncNews());
  }

  private async syncProductList() {
    console.log('开始同步产品列表...');
    const reitsList = await this.tushare.getREITsList();
    // 存储到数据库
    // 更新缓存
    console.log('产品列表同步完成');
  }

  private async syncFinancialData() {
    console.log('开始同步财务数据...');
    // 同步逻辑
    console.log('财务数据同步完成');
  }

  private async syncQuotes() {
    console.log('开始同步实时行情...');
    const quotes = await this.tushare.getRealtimeQuotes(['REIT001', 'REIT002']);
    // 存储到Redis
    // 推送到WebSocket
    console.log('实时行情同步完成');
  }

  private async syncNews() {
    console.log('开始同步新闻...');
    const news = await this.tushare.getNews();
    // 存储到数据库
    console.log('新闻同步完成');
  }
}
```

### 4.2 在Next.js中启动定时任务

```typescript
// app/api/cron/start/route.ts
import { DataSyncJob } from '@/lib/cron/data-sync-job';

export async function GET() {
  const job = new DataSyncJob();
  job.start();
  return Response.json({ message: '定时任务已启动' });
}
```

## 五、WebSocket实时推送

### 5.1 创建WebSocket服务

```typescript
// lib/services/websocket-service.ts
import { Server as SocketServer } from 'socket.io';
import { Server as HTTPServer } from 'http';
import { Redis } from 'ioredis';

export class WebSocketService {
  private io: SocketServer;
  private redis: Redis;

  constructor(httpServer: HTTPServer) {
    this.io = new SocketServer(httpServer, {
      cors: { origin: '*' },
      path: '/api/socket'
    });

    this.redis = new Redis(process.env.REDIS_URL!);

    this.setupConnection();
  }

  private setupConnection() {
    this.io.on('connection', (socket) => {
      console.log('客户端连接:', socket.id);

      // 订阅频道
      socket.on('subscribe', (channels: string[]) => {
        channels.forEach(channel => socket.join(channel));
      });

      // 取消订阅
      socket.on('unsubscribe', (channels: string[]) => {
        channels.forEach(channel => socket.leave(channel));
      });

      socket.on('disconnect', () => {
        console.log('客户端断开:', socket.id);
      });
    });
  }

  // 推送实时行情
  async pushQuotes(quotes: Quote[]) {
    quotes.forEach(quote => {
      this.io.to(`quote:${quote.code}`).emit('quote:update', quote);
    });
  }

  // 推送新闻
  async pushNews(news: NewsItem) {
    this.io.to('news').emit('news:update', news);
  }

  // 推送产品状态更新
  async pushProductStatus(productId: string, status: string) {
    this.io.to(`product:${projectId}`).emit('product:status', {
      productId,
      status,
      timestamp: new Date()
    });
  }
}
```

### 5.2 前端WebSocket客户端

```typescript
// hooks/useWebSocket.ts
import { useEffect, useState, useRef } from 'react';

export function useWebSocket(channel: string) {
  const [data, setData] = useState<any>(null);
  const [connected, setConnected] = useState(false);
  const socketRef = useRef<WebSocket | null>(null);

  useEffect(() => {
    const ws = new WebSocket('ws://localhost:5000/api/socket');
    
    ws.onopen = () => {
      console.log('WebSocket连接成功');
      setConnected(true);
      ws.send(JSON.stringify({ action: 'subscribe', channel }));
    };

    ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      setData(message);
    };

    ws.onclose = () => {
      console.log('WebSocket连接关闭');
      setConnected(false);
    };

    ws.onerror = (error) => {
      console.error('WebSocket错误:', error);
    };

    socketRef.current = ws;

    return () => {
      if (socketRef.current) {
        socketRef.current.close();
      }
    };
  }, [channel]);

  return { data, connected };
}
```

## 六、数据缓存策略

### 6.1 Redis缓存配置

```typescript
// lib/cache/redis-cache.ts
import { Redis } from 'ioredis';

export class RedisCache {
  private redis: Redis;

  constructor() {
    this.redis = new Redis(process.env.REDIS_URL!);
  }

  // 设置缓存
  async set(key: string, value: any, ttl: number = 3600) {
    await this.redis.setex(key, ttl, JSON.stringify(value));
  }

  // 获取缓存
  async get(key: string) {
    const value = await this.redis.get(key);
    return value ? JSON.parse(value) : null;
  }

  // 删除缓存
  async del(key: string) {
    await this.redis.del(key);
  }

  // 设置产品列表缓存（1小时）
  async setProductList(data: any[]) {
    await this.set('reits:products:list', data, 3600);
  }

  // 设置实时行情缓存（5秒）
  async setQuotes(data: any) {
    await this.set('quotes:realtime', data, 5);
  }

  // 设置财务数据缓存（1天）
  async setFinancialData(code: string, data: any) {
    await this.set(`financial:${code}`, data, 86400);
  }
}
```

### 6.2 缓存使用策略

```typescript
// app/api/reits/list/route.ts
import { TushareService } from '@/lib/services/tushare-service';
import { RedisCache } from '@/lib/cache/redis-cache';

const tushare = new TushareService(process.env.TUSHARE_TOKEN!);
const cache = new RedisCache();

export async function GET() {
  // 1. 尝试从缓存获取
  const cached = await cache.get('reits:products:list');
  if (cached) {
    return Response.json({ data: cached, fromCache: true });
  }

  // 2. 从API获取
  const data = await tushare.getREITsList();

  // 3. 更新缓存
  await cache.setProductList(data);

  // 4. 返回数据
  return Response.json({ data, fromCache: false });
}
```

## 七、数据更新流程

### 7.1 产品列表更新

**触发时机**：每天早上8:00
**更新内容**：
- 新增产品
- 产品状态变更
- 基本信息更新

**处理逻辑**：
```typescript
async updateProductList() {
  const newData = await this.getDataFromAPI();
  const oldData = await this.getFromDB();
  
  // 对比数据
  const changes = this.compareData(oldData, newData);
  
  // 更新数据库
  await this.updateDatabase(changes);
  
  // 通知客户端
  if (changes.added.length > 0) {
    await this.notifyClients('product:added', changes.added);
  }
  if (changes.updated.length > 0) {
    await this.notifyClients('product:updated', changes.updated);
  }
}
```

### 7.2 实时行情更新

**触发时机**：每5秒/交易时间
**更新内容**：
- 当前价格
- 涨跌幅
- 成交量
- 换手率

**处理逻辑**：
```typescript
async updateQuotes() {
  const codes = await this.getActiveProductCodes();
  const quotes = await this.getQuotesFromAPI(codes);
  
  // 存储到Redis（5秒过期）
  await this.cache.set('quotes:realtime', quotes, 5);
  
  // 推送到WebSocket
  await this.websocket.pushQuotes(quotes);
  
  // 记录历史数据
  await this.saveQuoteHistory(quotes);
}
```

### 7.3 财务数据更新

**触发时机**：每个财报发布日
**更新内容**：
- 营业收入
- 净利润
- 总资产
- 负债情况

**处理逻辑**：
```typescript
async updateFinancialData() {
  const codes = await this.getAllProductCodes();
  
  for (const code of codes) {
    const financialData = await this.getFinancialData(code);
    
    // 更新数据库
    await this.updateFinancialRecord(code, financialData);
    
    // 清除缓存
    await this.cache.del(`financial:${code}`);
    
    // 推送更新通知
    await this.notifyClients('financial:updated', { code, data: financialData });
  }
}
```

## 八、部署建议

### 8.1 环境变量配置

```env
# 数据源配置
TUSHARE_TOKEN=your_tushare_token
EASTMONEY_API_KEY=your_eastmoney_key

# Redis配置
REDIS_URL=redis://localhost:6379

# WebSocket配置
WS_PORT=5001
WS_PATH=/api/socket

# 定时任务配置
CRON_ENABLED=true
SYNC_INTERVAL=300  # 5分钟
```

### 8.2 启动顺序

```bash
# 1. 启动Redis
redis-server

# 2. 启动定时任务
npm run cron

# 3. 启动WebSocket服务
npm run websocket

# 4. 启动Next.js应用
npm run dev
```

## 九、监控和告警

### 9.1 数据同步监控

```typescript
// lib/monitor/sync-monitor.ts
export class SyncMonitor {
  async checkSyncStatus() {
    const lastSync = await this.getLastSyncTime();
    const now = new Date();
    const diff = (now.getTime() - lastSync.getTime()) / 1000 / 60; // 分钟

    if (diff > 15) {
      // 同步延迟超过15分钟，发送告警
      await this.sendAlert(`数据同步延迟：${diff}分钟`);
    }
  }

  async checkDataQuality() {
    const products = await this.getProductCount();
    if (products === 0) {
      await this.sendAlert('产品数据为空！');
    }
  }
}
```

## 十、成本估算

### 10.1 免费方案
- **Tushare**：免费（注册即可使用）
- **爬虫系统**：仅服务器成本
- **月成本**：约¥50-100（服务器费用）

### 10.2 付费方案
- **东方财富Choice**：约¥5000/年
- **同花顺iFinD**：约¥8000/年
- **Wind**：约¥20,000/年（机构版）

## 总结

**推荐方案**：
1. **初期（MVP）**：使用Tushare + 自建爬虫，成本最低
2. **中期（成长期）**：集成东方财富API，数据更稳定
3. **长期（规模化）**：使用Wind专业版，数据最全面

**关键点**：
- ✅ 使用Redis缓存减轻API压力
- ✅ WebSocket实现实时推送
- ✅ 定时任务保证数据定期更新
- ✅ 监控告警确保数据质量
- ✅ 降级策略应对API故障
